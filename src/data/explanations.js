export function getQuestionExplanation(questionId, language) {
    const explanations = {
      q1: {
        en: "a) Is not correct. It is impossible to prove that there are no defects anymore in the system under test. See testing principle 1 \nb) Is not correct. See testing principle 7 \n<b>c) Is correct. Testing finds defects and failures which reduces the level of risk and at the same time gives more confidence in the quality level of the test object</b> \nd) Is not correct. It is impossible to test all combinations of inputs (see testing principle 2)",
        fr: "a) Incorrect. Il est impossible de prouver qu'il n'y a plus de défauts dans le système sous test. (Principe de test n°1) \nb) Incorrect. Les tests logiciels ne peuvent pas garantir qu'il n'y aura aucun dysfonctionnement futur. (Principe de test n°7) \n<b>c) Correct. Les tests permettent de découvrir des défauts et des défaillances, ce qui réduit le niveau de risque associé au logiciel et renforce la confiance dans sa qualité.</b> \nd) Incorrect. Il est impossible de tester toutes les combinaisons d'entrées possibles. (Principe de test n°2)"
      },
      q2: {
        en: "<b>a) Is correct. It is important that testers are involved from the beginning of the software development lifecycle (SDLC). It will increase understanding of design decisions and will detect defects early.</b> \nb) Is not correct. Both developers and testers will have more understanding of each other's work products and how to test the code \nc) Is not correct. End users will not help the testers in increasing the quality of defect reports; also, users usually do not participate in low-level testing levels like integration testing \nd) Is not correct. Being certified does not automatically mean that the tester will be better in test design",
        fr: "<b>a) Correct. Il est important que les testeurs soient impliqués dès le début du cycle de vie du développement logiciel (SDLC). Cela permettra une meilleure compréhension des décisions de conception et une détection plus précoce des défauts.</b> \nb) Incorrect. Les développeurs et les testeurs auront une meilleure compréhension des produits de travail de chacun et de la manière de tester le code.\nc) Incorrect. Les utilisateurs finaux n'aideront pas les testeurs à améliorer la qualité des rapports de défauts ; de plus, les utilisateurs ne participent généralement pas aux niveaux de test de bas niveau comme les tests d'intégration.\nd) Incorrect. Être certifié ne signifie pas automatiquement que le testeur sera meilleur en conception de tests."
      },
      q3: {
        en: "<b>a) Is correct. This principle means that if the same tests are repeated over and over again, eventually these tests no longer find any new defects. This is probably why the tests all passed in this release as well</b> \nb) Is not correct. This principle says about the mistaken belief that just finding and fixing a large number of defects will ensure the success of a system\nc) Is not correct. This principle says that a small number of components usually contain most of the defects\nd) Is not correct. This principle states that testing all combinations of inputs and preconditions is not feasible",
        fr: "<b>a) Correct. Ce principe signifie que si les mêmes tests sont répétés indéfiniment, ils finissent par ne plus détecter de nouveaux défauts. C'est probablement la raison pour laquelle tous les tests ont été réussis dans cette version également.</b> \nb) Incorrect. Ce principe concerne l'idée fausse selon laquelle le simple fait de trouver et de corriger un grand nombre de défauts garantira le succès d'un système.\nc) Incorrect. Ce principe stipule qu'un petit nombre de composants contiennent généralement la plupart des défauts.\nd) Incorrect. Ce principe précise qu'il n'est pas possible de tester toutes les combinaisons d'entrées et de conditions préalables."
      },
      q4: {
        en: "a) Is not correct. Estimating the test effort is part of test planning\n<b>b) Is correct. This is an example of defining test conditions which is a part of test analysis</b>\nc) Is not correct. Using test techniques to derive coverage items is a part of test design\nd) Is not correct. Reporting defects found during dynamic testing is a part of test execution",
        fr: "a) Incorrect. L'estimation de l'effort de test fait partie de la planification des tests. \n<b>b) Correct. Il s'agit d'un exemple de définition des conditions de test, qui fait partie de l'analyse de test.</b> \nc) Incorrect. L'utilisation de techniques de test pour dériver des éléments de couverture fait partie de la conception de test.\nd) Incorrect. Le signalement des défauts trouvés pendant les tests dynamiques fait partie de l'exécution des tests."
      },
      q5: {
        en: "<b>i. Is true. The SDLC has an influence on the test approach</b>\nii. Is false. The number of defects detected in previous projects may have some influence, but this is not as significant as i, iii and iv\n<b>iii. Is true. The identified product risks are one of the most important factors influencing the test approach\niv. Is true. Regulatory requirements are important factors influencing the test approach</b>\nv. Is false. The test environment has no significant influence on the test approach\n\nThus:\na) Is not correct\n<b>b) Is correct</b>\nc) Is not correct\nd) Is not correct",
        fr: "<b>i. Vrai. Le SDLC a une influence sur le processus de test.</b>\nii. Faux. Le nombre de défauts détectés dans des projets précédents peut avoir une certaine influence, mais elle n'est pas aussi significative que i, iii et iv.\n<b>iii. Vrai. Les risques identifiés du produit sont l'un des facteurs les plus importants influençant le processus de test.</b>\n<b>iv. Vrai. Les exigences réglementaires sont des facteurs importants qui influencent le processus de test. On devrait plutôt dire 'nouvelles exigences réglementaires imposant des tests en boîte blanche formels'.</b>\nv. Faux. L'environnement de test n'a pas d'influence significative sur le processus de test. (Il est important de noter que bien que l'environnement de test ne soit pas un facteur SIGNIFICATIF, il joue tout de même un rôle dans la réussite des tests).\n\nJustification des choix de réponse:\na) Incorrect.\n<b>b) Correct.</b>\nc) Incorrect.\nd) Incorrect."
      },
      q6: {
        en: "<b>a) Is correct. This is done by the testers</b>\nb) Is not correct. The product backlog is built and maintained by the product owner\nc) Is not correct. This is done by the development team\nd) Is not correct. This is a managerial role\n<b>e) Is correct. This is done by the testers since its technical task done as part of a test analysis.</b>",
        fr: "<b>a) Correct. La configuration des environnements de test est une tâche effectuée par les testeurs.</b> \nb) Incorrect. Le backlog produit est construit et maintenu par le product owner.\nc) Incorrect. Ceci est réalisé par l'équipe de développement.\nd) Incorrect. Il s'agit d'une tâche de management. \n<b>e) Correct. Cela se fait par les testeurs car sa tâche technique effectuée dans le cadre d'une analyse de test.</b>"
      },
      q7: {
        en: "<b>i. Is true. Having domain knowledge is an important tester skill</b>\nii. Is false. This is a task of the business analyst together with thebusiness representative \n<b>iii. Is true. Being a good team player is an important skill</b>\niv. Is false. Planning and organizing the work of the team is a task of the test manager or, mostly in an Agile software development project, the whole team and not just the tester\n<b>v. Is true. Critical thinking is one of the most important skills of testers</b>\n\nThus:\na) Is not correct\n<v>b) Is correct</b>\nc) Is not correct\nd) Is not correct",
        fr: "<b>i. Vrai. Avoir une connaissance du domaine est une compétence importante pour un testeur.</b>\nii. Faux. C'est une tâche de l'analyste d'affaires en collaboration avec le représentant d'affaires.\n<b>iii. Vrai. Être un bon joueur d'équipe est une compétence importante.</b>\niv. Faux. Planifier et organiser le travail de l'équipe est une tâche du responsable des tests ou, plus souvent dans un projet de développement logiciel Agile, de toute l'équipe et pas seulement du testeur.\n<b>v. Vrai. L'esprit critique est l'une des compétences les plus importantes pour les testeurs.</b>\n\nJustification des choix de réponse:\na) Incorrect\nb) Correct\nc) Incorrect\nd) Incorrect"
      },
      q8: {
        en: "a) Is not correct. The test automation approach is defined by testers with the help of developers and business representatives \nb) Is not correct. The test strategy is decided in collaboration with the developers \nc) Is not correct. Testers, developers, and business representatives are part of the whole team approach \n<b>d) Is correct. Testers will work closely with business representatives to ensure that the desired quality levels are achieved. This includes supporting and collaborating with them to help them create suitable acceptance tests</b>",
        fr: "a) Incorrect. L'approche d'automatisation des tests est définie par les testeurs avec l'aide des développeurs et des représentants d'affaires.\nb) Incorrect. La stratégie de test est définie en collaboration avec les développeurs.\nc) Incorrect. Les testeurs, les développeurs et les représentants d'affaires font tous partie de l'approche d'équipe entière. \n<b>d) Correct. Les testeurs travaillent en étroite collaboration avec les représentants d'affaires pour garantir l'atteinte des niveaux de qualité souhaités. Cela comprend le soutien et la collaboration avec eux pour les aider à créer des tests d'acceptation appropriés.</b>"
      },
      q9: {
        en: "a) Is not correct\nb) Is not correct\nc) Is not correct\n<b>d) Is correct. This rule holds for all SDLC models</b>",
        fr: "a) Incorrect. Même dans les modèles en cascade, il existe des tests unitaires effectués pendant le codage, par exemple.\nb) Incorrect. Les modèles itératifs impliquent des tests continus tout au long du cycle de développement itératif.\nc) Incorrect. Les modèles incrémentaux ont également des activités de test associées à chaque incrément livré. \n<b>d) Correct. Cette règle s'applique à tous les modèles SDLC.</b>"
      },
      q10: {
        en: "a) Is not correct. It is more often used in behavior-driven development(BDD)\nb) Is not correct. It is the description of test-driven development (TDD)\n<b>c) Is correct. In acceptance test-driven development (ATDD) tests arewritten from acceptance criteria as part of the design process</b>\nd) Is not correct. It is used in BDD",
        fr: "a) Incorrect. Le format donné/quand/alors est plus souvent utilisé dans le développement piloté par le comportement (BDD) \nb) Incorrect. Cela correspond à la description du développement piloté par les tests (TDD). \n<b>c) Correct. Dans le développement piloté par les tests d'acceptation (ATDD), les tests sont écrits à partir des critères d'acceptation dans le cadre du processus de conception.</b> \nd) Incorrect. C'est vrai pour l'ATDD et le BDD, et pas seulement pour l'ATDD."
      },
      q11: {
        en: "a) Is not correct. Early review is an example of the shift left approach\nb) Is not correct. TDD is an example of the shift left approach\nc) Is not correct. Early non-functional testing is an example of the shift left approach\n<b>d) Is correct. Test scripts should be subject to configuration management,so it makes no sense to create the test scripts before this process is setup</b>",
        fr: "a) Incorrect. L'examen précoce est un exemple de l'approche « shift left ».\nb) Incorrect. Le TDD (Test-Driven Development) est un exemple de l'approche « shift left ».\nc) Incorrect. Les tests non fonctionnels précoces sont un exemple de l'approche « shift left ». \n<b>d) Correct. Les scripts de test doivent être soumis à la gestion de configuration. Il est donc inutile de créer les scripts de test avant que ce processus ne soit mis en place.</b>"
      },
      q12: {
        en: "a) Is not correct. Retrospectives are more useful for identifyingimprovement opportunities and have little importance for clients\nb) Is not correct. Retrospectives are not aimed to collect feedback aboutthe product, but about the process. Additionally, retrospectives areinternal activity for the team and should not include end userrepresentatives\n<b>c) Is correct. Regularly conducted retrospectives, when appropriate followup activities occur, are critical to continual improvement of developmentand testing</b>\nd) Is not correct. Courage and respect are values of ExtremeProgramming and are not closely related to retrospectives",
        fr: "a) Incorrect. Les rétrospectives sont plus utiles pour identifier les opportunités d'amélioration et ont peu d'importance pour les clients.\nc) Correct. Des rétrospectives menées régulièrement, suivies d'actions de suivi appropriées, sont essentielles à l'amélioration continue du développement et des tests.\nb) Incorrect. Les représentants d'affaires ne donnent pas de feedback sur le produit lui-même. Par conséquent, il n'y a pas de gain financier pour l'organisation.\n<b>c) Correct. Des rétrospectives menées régulièrement, suivies d'actions de suivi appropriées, sont essentielles à l'amélioration continue du développement et des tests.</b>\nd) Incorrect. Le courage et le respect sont des valeurs de la programmation extrême (Extreme Programming) et ne sont pas étroitement liées aux rétrospectives."
      },
      q13: {
        en: "Considering:\n• The test basis for acceptance testing is the user's business needs(1D)\n• Communication between components is tested during componentintegration testing (2B)\n• Failures in logic can be found during component testing (3A)\n• Business rules are the test basis for system testing (4C)\n\nThus:\n<b>a) Is correct</b>\nb) Is not correct\nc) Is not correct\nd) Is not correct",
        fr: "• Le test d'acceptation a pour base de test les besoins métier de l'utilisateur (1D).\n• La communication entre les composants est testée lors du test d'intégration des composants (2B).\n• Les défaillances de logique peuvent être détectées lors du test unitaire (3A).\n• Les règles métier constituent la base de test pour le test système (4C).\n<b>a) 1D, 2B, 3A, 4C</b>"
      },
      q14: {
        en: "Because TC1 and TC3 failed in Execution 1 (i.e., test (1) and test (3)), test(4) and test (6) are confirmation tests.Because TC2 and TC3 failed in Execution 2 (i.e., tests (5) and (6)), test (8)and test (9) are also confirmation tests.TC2 passed in Execution 1 (i.e., test (2)), so test (5) is a regression test.TC1 passed in the Execution 2 (i.e., test (4)), so test (7) is also a regressiontest.\n\nThus:\na) Is not correct\n<b>b) Is correct</b>\nc) Is not correct\nd) Is not correct",
        fr: "Étant donné que TC1 et TC3 ont échoué dans l'exécution 1 (c'est-à-dire le test (1) et le test (3)), le test (4) et le test (6) sont des tests de confirmation.Étant donné que TC2 et TC3 ont échoué dans l'exécution 2 (c'est-à-dire que les tests (5) et (6)), le test (8) et le test (9) sont également des tests de confirmation.TC2 passé dans l'exécution 1 (c'est-à-dire le test (2)), donc le test (5) est un test de régression.TC1 a réussi dans l'exécution 2 (c'est-à-dire le test (4)), donc le test (7) est également un test de régression.\n\nAinsi:\na) n'est pas correct\n<b>b) est correct</b>\nc) n'est pas correct\nd) n'est pas correct"
      },
      q15: {
        en: "<b>a) Is correct. Defect management is no less expensive. Finding and fixingdefects later in SDLC is more costly</b>\nb) Is not correct. This is a benefit of static testing\nc) Is not correct. This is a benefit of static testing\nd) Is not correct. This is a benefit of static testing",
        fr: "<b>a) Correct. La gestion des défauts n'est pas moins coûteuse. La découverte et la correction des défauts plus tard dans le SDLC sont plus coûteux.</b>\nb) Incorrect. C'est un avantage des tests statiques.\nc) Incorrect. C'est un avantage des tests statiques.\nd) Incorrect. C'est un avantage des tests statiques."
      },
      q16: {
        en: "a) Is not correct. Feedback can improve the test process, but if one onlywants to improve future projects, the feedback does not need to comeearly or frequently\nb) Is not correct. Feedback is not used to prioritize requirements\nc) Is not correct. There is no one, recommended way to measure qualityof changes. Also, this is not one of the benefits of early feedback thatare mentioned in section 3.2.1\n<b>d) Is correct. Early and frequent feedback can prevent misunderstandingsabout requirements</b>",
        fr: "a) Faux. Le feedback peut améliorer le processus de test, mais si l'on veut seulement améliorer les projets futurs, le feedback n'a pas besoin d'être précoce ou fréquent.\nb) Faux. Le feedback n'est pas utilisé pour prioriser les exigences. La priorisation se fait généralement en fonction de la valeur commerciale et du risque.\nc) Faux. La qualité des changements peut être mesurée de plusieurs façons, par exemple, par des tests unitaires, des tests d'intégration et des tests fonctionnels.\n<b>d) Correct. Un feedback précoce et fréquent permet une communication rapide des problèmes potentiels de qualité. Plus tôt les problèmes sont identifiés, plus tôt des actions correctives peuvent être prises, ce qui permet d'éviter des malentendus sur les exigences.</b>"
      },
      q17: {
        en: "Considering the attributes:\n• Specified for walkthroughs, technical reviews, and inspections; thus,the reviews being performed cannot be informal reviews\n• The purpose of evaluating quality is one of the most importantobjectives of a walkthrough\n• This is not allowed for inspections and is typically not done intechnical reviews. A moderator is needed in walkthroughs and isallowed for informal reviews\n• All types of reviews can include individual preparation (even informalreviews)\n• All types of reviews can produce a review report, although informalreviews do not require documentation\n\nThus:\na) Is not correct\n<b>b) Is correct</b>\nc) Is not correct\nd) Is not correct",
        fr: "a) Revue informelle - Exclue. La présence d'un scribe, d'un rapport de revue et la préparation individuelle ne sont pas des caractéristiques typiques des revues informelles.\n<b>b) Relecture technique - Correcte. Les relectures techniques partagent tous les attributs mentionnés. Le but principal est l'évaluation de la qualité, l'auteur dirige la réunion, et une préparation individuelle ainsi qu'un rapport de revue sont souvent présents.</b>\nc) Revue technique - Exclue. Les revues techniques ont un objectif similaire, mais elles sont généralement plus formelles que les relectures techniques et nécessitent souvent un modérateur distinct de l'auteur.\nb) Relecture technique - Correcte. Les relectures techniques partagent tous les attributs mentionnés. Le but principal est l'évaluation de la qualité, l'auteur dirige la réunion, et une préparation individuelle ainsi qu'un rapport de revue sont souvent présents.\nd) Inspection - Exclue. Les inspections sont des revues très formelles qui ne permettent pas à l'auteur de diriger la réunion."
      },
      q18: {
        en: "a) Is not correct. Adequate time for individuals is a success factor\nb) Is not correct. Splitting work products into small adequate parts is asuccess factor\nc) Is not correct. Avoiding behaviors that might indicate boredom,exasperation, etc. is a success factor\n<b>d) Is correct. During reviews one can find defects, not failures</b>",
        fr: "a) Faux. Consacrer suffisamment de temps aux participants est un facteur de réussite.\nb) Faux. Diviser les produits de travail volumineux en parties plus petites et plus gérables est un facteur de réussite.\nc) Faux. Éviter les comportements négatifs est un facteur de réussite. Un environnement respectueux et positif favorise une discussion constructive et une identification plus efficace des défauts.\n<b>d) Correct. Lors des revues, on trouve des défauts, pas des échecs.</b>"
      },
      q19: {
        en: "a) Is not correct. This is a common characteristic of white-box testtechniques. Test conditions, test cases, and test data are derived froma test basis that may include code, software architecture, detaileddesign, or any other source of information regarding the structure of thesoftware.\nb) Is not correct. This is a common characteristic of white-box testtechniques. Coverage is measured based on the items tested within aselected structure and the technique applied to the test basis\n<b>c) Is correct. This is a common characteristic of experience-based testtechniques. This knowledge and experience include expected use ofthe software, its environment, likely defects, and the distribution ofthose defects is used to define tests</b>\nd) Is not correct. This is a common characteristic of black-box testtechniques. Test cases may be used to detect gaps within requirementsand the implementation of the requirements, as well as deviations fromthe requirements",
        fr: "a) Faux. Il s'agit d'une caractéristique courante des techniques de test en boîte blanche (white-box). Les conditions de test, les cas de test et les données de test sont dérivés d'une base de test qui peut inclure le code, l'architecture logicielle, la conception détaillée ou toute autre source d'information relative à la structure du logiciel.\nc) Correct. Les techniques de test basées sur l'expérience s'appuient fortement sur la connaissance du testeur du logiciel et du domaine d'activité. Cette connaissance et cette expérience, qui comprennent l'utilisation prévue du logiciel, son environnement, les défauts probables et la distribution de ces défauts, sont utilisées pour définir les tests.\nb) Faux. Il s'agit d'une caractéristique courante des techniques de test en boîte blanche. La couverture est mesurée en fonction des éléments testés au sein d'une structure sélectionnée et de la technique appliquée à la base de test.\n<b>c) Correct. Les techniques de test basées sur l'expérience s'appuient fortement sur la connaissance du testeur du logiciel et du domaine d'activité. Cette connaissance et cette expérience, qui comprennent l'utilisation prévue du logiciel, son environnement, les défauts probables et la distribution de ces défauts, sont utilisées pour définir les tests.</b>\nd) Faux. Il s'agit d'une caractéristique courante des techniques de test en boîte noire (black-box). Les cas de test peuvent être utilisés pour détecter des lacunes dans les exigences et la mise en œuvre des exigences, ainsi que des écarts par rapport aux exigences."
      },
      q20: {
        en: "“Small garden” and “large garden” can go only with “ground floor”, so weneed two test cases with “ground floor” which cover these two “garden type”partitions.\nWe need two more test cases to cover the two other “floor” partitions and aremaining ”garden type” partition of “no garden”.We need a total of four test cases:\nTC1 (ground floor, small garden)\nTC2 (ground floor, large garden)\nTC3 (first floor, no garden)\nTC4 (second or higher floor, no garden)\n\nThus:\na) Is not correct\n<b>b) Is correct</b>\nc) Is not correct\nd) Is not correct",
        fr: "a) 3 - Faux (voir justification de la réponse b)\n<b>b) Correct - En analysant les combinaisons possibles, on constate que 'Petit jardi' et 'Grand jardin' ne peuvent aller qu'avec 'Rez-de-chaussée'. Nous avons donc besoin de deux cas de test avec 'Rez-de-chaussée' pour couvrir ces deux partitions de 'Type de jardin'.Il nous faut ensuite deux autres cas de test pour couvrir les deux autres partitions d'Étage et la partition restante de 'Type de jardin' qui est 'Pas de jardin'.Au total, nous avons besoin de quatre cas de test :\n- CT1 (Rez-de-chaussée, Petit jardin)\n- CT2 (Rez-de-chaussée, Grand jardin)\n- CT3 (Premier étage, Pas de jardin)\n- CT4 (Deuxième étage ou plus, Pas de jardin)\nEn résumé, quatre cas de test sont nécessaires pour atteindre une couverture PE de 100 % dans ce scénario.</b>\nc) 5 - Faux (voir justification de la réponse b)\nd) 6 - Faux (voir justification de la réponse b)"
      },
      q21: {
        en:"There are 12 boundary values for the final result values: 0, 50, 51, 60, 61,70, 71, 80, 81, 90, 91, and 100.The test cases cover six of them (TC1 - 91, TC2 - 50, TC3 - 81, TC4 - 60,TC5 - 70 and TC7 - 51).\nTherefore, the test cases cover 6/12 = 50%.\n\nThus:\n<b>a) Is correct</b>\nb) Is not correct\nc) Is not correct\nd) Is not correct",
        fr: "<b>a (correct) \nIl y a 12 valeurs limites pour les résultats finaux : 0, 50, 51, 60, 61, 70, 71, 80, 81, 90, 91 et 100.Les cas de test en couvrent six (TC1 - 91, TC2 - 50, TC3 - 81, TC4 - 60, TC5 - 70 et TC7 - 51).Par conséquent, les cas de test couvrent 6/12, soit 50 % des valeurs limites.</b>\nb) 60% - Cette option est incorrecte car seuls 50 % des valeurs limites sont couvertes.\nc) 33.3% - Cette option est incorrecte car le pourcentage de couverture est supérieur à 33.3 %.\nd) 100% - Cette option est incorrecte car tous les cas limites ne sont pas couverts (seulement 6 sur 12)."
      },
      q22: {
        en: "a) Is not correct. A member without a missed deadline can get a discountand a gift T-Shirt after 15 bicycle rentals\nb) Is not correct. A member without a missed deadline can get a discountbut no gift T-Shirt until they rented a bicycle 15 times\nc) Is not correct. Non-members cannot get a discount, even if they did notmiss a deadline yet\n<b>d) Is correct. No discount as a non-member that has also missed adeadline, but only members can receive a gift T-Shirt. Hence, the actionis not correct</b>",
        fr: "a) R4 - Un membre sans retard de retour peut obtenir une réduction et un T-Shirt cadeau après 15 locations de vélo.\nb) R2 - Un membre sans retard de retour peut obtenir une réduction mais pas de T-Shirt cadeau tant qu'il n'a pas loué de vélo 15 fois.\nc) R6 - Les non-membres ne peuvent pas bénéficier d'une réduction, même s'ils n'ont pas encore dépassé le délai de retour.\n<b>d) Correct. Pas de remise pour un non-membre qui a également dépassé le délai de retour. De plus, seuls les membres peuvent recevoir un cadeau. Par conséquent, l'action n'est pas possible.</b>"
      },
      q23: {
        en: "“test” and “error” transitions cannot occur in one test case.Neither can both “done” transitions.This means we need at least three test cases to achieve transitioncoverage. For example:\nTC1: test, done\nTC2: run, error, done\nTC3: run, pause, resume, pause, done\n\nThus:\na) Is not correct\nb) Is not correct\nc) Is not correct\n<b>d) Is correct</b>",
        fr: "a) 4 - Ce n'est pas le nombre minimal de cas de test.\nb) 2 - Ce n'est pas le nombre minimal de cas de test.\nc) 7 - Ce n'est pas le nombre minimal de cas de test.\n<b>d) Correct - 3\nJustification:Les transitions 'test' et 'erreur' ne peuvent pas se produire dans un seul cas de test.De même, les deux transitions 'terminé' ne peuvent pas se produire non plus.Cela signifie que nous avons besoin d'au moins trois cas de test pour atteindre la couverture des transitions. Par exemple :\nCT1 : test, terminé\nCT2 : exécuter, erreur, terminé\nCT3 : exécuter, pause, reprendre, pause, terminé\nJustification des autres choix de réponse incorrects</b>"
      },
      q24: {
        en: "<b>a) Is correct. Since 100% statement coverage is achieved, everystatement, including the ones with defects, must have been executedand evaluated at least once</b>\nb) Is not correct. Coverage depends on what is tested, not on the numberof test cases. For example, for code “if (x==0) y=1”, one test case (x=0)achieves 100% statement coverage, but two test cases (x=1) and (x=2)together achieve only 50% statement coverage\nc) Is not correct. If there is a loop in the code there may be an infinitenumber of possible paths, so it is not possible to execute all thepossible paths in the code\nd) Is not correct. Exhaustive testing is not possible (see the seven testingprinciples section in the syllabus). For example, for code “input x; printx” any single test with arbitrary x achieves 100% statement coverage,but covers one input value",
        fr: "<b>a) Correct. Puisque une couverture des instructions de 100 % est atteinte, chaque instruction, y compris celles contenant des défauts, a dû être exécutée et évaluée au moins une fois.</b>\nb) Faux. La couverture dépend de ce qui est testé, et non du nombre de cas de test. Par exemple, pour le code 'If (x==0) y=1', un cas de test (x=0) atteint une couverture de code de 100 %, mais deux cas de test (x=1) et (x=2) ensemble n'atteignent qu'une couverture de 50 %.\nc) Faux. S'il y a une boucle dans le code, il peut y avoir un nombre infini de chemins possibles. Il n'est donc pas possible d'exécuter tous les chemins possibles dans le code.\nd) Faux. Les tests exhaustifs ne sont pas possibles (voir la section sur les sept principes de test dans le syllabus). Par exemple, pour le code 'saisir x ; afficher x', un seul test avec une valeur arbitraire de x atteint une couverture de code de 100 %, mais ne couvre qu'une seule valeur d'entrée."
      },
      q25: {
        en: "a) Is not correct. The fundamental strength of white-box test techniques is that the entire software implementation is taken into account during testing \nb) Is not correct. White-box coverage measures provide an objective measure of coverage and provide the necessary information to allow additional tests to be generated to increase this coverage \nc) Is not correct. White-box test techniques can be used to perform reviews (static testing) \n<b>d) Is correct. This is the weakness of the white-box test techniques. They are not able to identify the missing implementation, because they are based solely on the test object structure, not on the requirements specification</b>",
        fr: "a) Faux. Le principal atout des techniques de test en boîte blanche est de prendre en compte l'intégralité de l'implémentation logicielle lors des tests.\nb) Faux. Les mesures de couverture en boîte blanche fournissent une mesure objective de la couverture et permettent de générer des tests supplémentaires pour l'augmenter.\nc) Faux. Les techniques de test en boîte blanche peuvent être utilisées pour effectuer des analyses (tests statiques).\n<b>d) Correct. C'est le point faible des techniques de test en boîte blanche. Elles ne sont pas en mesure d'identifier les implémentations manquantes, car elles se basent uniquement sur la structure de l'objet testé, et non sur le cahier des charges.</b>"
      },
      q26: {
        en: "<b>a) Is correct. The basic concept behind error guessing is that the tester tries to guess what errors may have been made by the developer and what defects may be in the test object based on past experience (and sometimes checklists)</b> \nb) Is not correct. Although a testers who used to be a developer may use their personal experience to help them when performing error guessing, the test technique is not based on prior knowledge of development \nc) Is not correct. Error guessing is not a usability technique for guessing how users may fail to interact with the test object \nd) Is not correct. Duplicating the development task has several flaws that make it impractical, such as the tester having equivalent skills to the developer and the time involved to perform the development. It is not error guessing",
        fr: "<b>a) Correct. Le concept fondamental de l'estimation d'erreurs est que le testeur essaie de deviner quelles erreurs ont pu être commises par le développeur et quels défauts peuvent se trouver dans l'objet de test en se basant sur son expérience passée (et parfois sur des checklists).</b> \nb) Faux. Bien qu'un testeur ayant été développeur puisse utiliser son expérience personnelle pour l'aider à effectuer une estimation d'erreurs, cette technique de test ne repose pas sur des connaissances préalables en développement.\nc) Faux. L'estimation d'erreurs n'est pas une technique d'utilisabilité qui consiste à deviner comment les utilisateurs pourraient mal interagir avec l'objet de test.\nd) Faux. La duplication de la tâche de développement présente plusieurs inconvénients qui la rendent impraticable, tels que le fait que le testeur doive avoir des compétences équivalentes à celles du développeur et le temps nécessaire pour effectuer le développement. Ce n'est pas de l'estimation d'erreurs."
      },
      q27: {
        en: "a) Is not correct. This is a new product. You probably do not have a checklist yet and test conditions might not be known due to missing requirements \nb) Is not correct. This is a new product. You probably do not have enough information to make correct error guesses \n<b>c) Is correct. Exploratory testing is most useful when there are few known specifications and/or there is a pressing timeline for testing</b> \nd) Is not correct. Branch testing is time-consuming, and your management is asking about some test results now. Also, branch testing does not involve domain knowledge",
        fr: "a) Tests basés sur des checklists - Il s'agit d'un nouveau produit. Vous n'avez probablement pas encore de liste de contrôle et les conditions de test peuvent être inconnues en raison de l'absence d'exigences.\nb) Estimation d'erreurs - Il s'agit d'un nouveau produit. Vous n'avez probablement pas assez d'informations pour faire des estimations d'erreurs correctes.\n<b>c) Correct - Tests exploratoires: Les tests exploratoires sont les plus utiles lorsqu'il existe peu de spécifications connues et/ou qu'il y a un délai d'exécution des tests serré.</b> \nd) Tests de branches - Les tests de branches prennent du temps, et votre direction souhaite des résultats de test dès maintenant. De plus, les tests de branches ne font pas appel aux connaissances du domaine."
      },
      q28: {
        en: "a) Is not correct. Retrospectives are used to capture lessons learned and to improve the development and testing process, not to document the acceptance criteria \n<b>b) Is correct. This is the standard way to document acceptance criteria \nc) Is not correct. Verbal communication does not allow to physically document the acceptance criteria as part of a user story (”card” aspect in the 3C's model)</b> \nd) Is not correct. Acceptance criteria are related to a user story, not a test plan. Also, acceptance criteria are the conditions that have to be fulfilled to decide if the user story is complete. Risks are not such conditions",
        fr: "a) Réaliser des rétrospectives - Les rétrospectives servent à capturer les leçons apprises et à améliorer le processus de développement et de test, et non à documenter les critères d'acceptation.\n<b>b) Correct - Utiliser le format donné/quand/alors: Le format donné/quand/alors est une approche courante pour documenter les critères d'acceptation de manière concise et claire.</b>\nc) Communication verbale - La communication verbale ne permet pas de documenter physiquement les critères d'acceptation dans le cadre d'une user story (aspect 'carte' dans le modèle des 3C).\nd) Documenter les risques - Les critères d'acceptation sont liés à une user story, pas à un plan de test. De plus, les critères d'acceptation sont les conditions qui doivent être remplies pour décider si la user story est complète. Les risques ne sont pas de telles conditions."
      },
      q29: {
        en: "<b>a) Is correct. This test covers two acceptance criteria: one about editing the document and one about saving changes</b> \nb) Is not correct. Acceptance criteria cover the editor activities, not the content owner activities \nc) Is not correct. Scheduling the edited content for publication may be a nice feature, but it is not covered by the acceptance criteria \nd) Is not correct. Acceptance criteria state about reassigning from an editor to the content owner, not to another editor",
        fr: "<b>a) Correct - Tester l'enregistrement du document après modification :\nCe test couvre deux critères d'acceptation : un sur la modification du document et un sur l'enregistrement des modifications.</b> \nb) Le propriétaire du contenu - Les critères d'acceptation concernent les activités du rédacteur en chef, et non celles du propriétaire du contenu.\nc) Programmation de la publication - La programmation de la publication du contenu modifié peut être une fonctionnalité intéressante, mais elle n'est pas couverte par les critères d'acceptation.\nd) Réattribution à un autre rédacteur - Les critères d'acceptation stipulent une réattribution à un 'propriétaire du contenu', et non à un autre rédacteur."
      },
      q30: {
        en: "a) Is not correct. Priorities for user stories are determined by the business representative together with the development team \nb) Is not correct. Testers focus on both functional and non-functional aspects of the system to be tested \n<b>c) Is correct. According to the syllabus, this is one of the ways testers add value to iteration and release planning</b> \nd) Is not correct. Early test design is not part of release planning. Early test design does not automatically guarantee the release of quality software",
        fr: "a) Priorisation des user stories - Les priorités des user stories sont déterminées par le représentant métier en collaboration avec l'équipe de développement.\nb) Fonctionnalités du système - Les testeurs se concentrent à la fois sur les aspects fonctionnels et non fonctionnels du système à tester.\n<b>c) Correct - Identification et évaluation des risques\nEn participant à l'identification et à l'évaluation détaillées des risques des user stories, les testeurs peuvent :\n- Identifier les domaines à tester en priorité.\n- Estimer l'effort de test nécessaire.\n- Suggérer des modifications à la conception pour atténuer les risques.\n- Contribuer à la création de plans de test plus efficaces.</b> \nd) Conception de tests en amont et garantie de qualité - La conception de tests en amont ne fait pas partie de la planification des versions. De plus, la conception de tests en amont ne garantit pas automatiquement la publication de logiciels de qualité."
      },
      q31: {
        en: "a) Is not correct. Test environment readiness is a resource availability criterion; hence it belongs to the entry criteria \nb) Is not correct. This is a resource availability criterion; hence it belongs to the entry criteria \n<b>c) Is correct. Estimated defect density is a measure of diligence; hence it belongs to the exit criteria.</b> \nd) Is not correct. Requirements translated into a given format result in testable requirements; hence it belongs to the entry criteria \n<b>e) Is correct. Automation of regression tests is a completion criterion; hence it belongs to the exit criteria</b>",
        fr: "a) Disponibilité de l'environnement de test - La disponibilité de l'environnement de test est un critère de disponibilité des ressources ; il s'agit donc d'un critère d'entrée.\nb) Capacité du testeur à se connecter à l'objet de test - Il s'agit également d'un critère de disponibilité des ressources ; il s'agit donc d'un critère d'entrée.\n<b>c) Densité estimée des défauts atteinte - La densité estimée des défauts est une mesure de la diligence ; elle appartient donc aux critères de sortie. Un seuil de densité de défauts acceptable peut être défini comme un critère de sortie pour arrêter les tests.</b>\nd) Exigences traduites au format donné/quand/alors - La traduction des exigences dans un format donné permet d'obtenir des exigences testables ; il s'agit donc d'un critère d'entrée.\n<b>e) Tests de régression automatisés - L'automatisation des tests de régression est un critère d'achèvement ; il appartient donc aux critères de sortie. L'automatisation des tests de régression garantit que les tests de régression peuvent être exécutés rapidement et efficacement lors des cycles de test ultérieurs.</b>"
      },
      q32: {
        en: "In the three-point estimation technique: \nE = (optimistic + 4*most likely + pessimistic)/6 \nE = (2+(4*11)+14)/6 = 10 \n\nThus: \na) Is not correct \nb) Is not correct \nc) Is not correct \n<b>d) Is correct</b>",
        fr: "a) 9 personne-heures - Ce n'est pas le résultat du calcul de l'estimation finale. \nb) 14 personne-heures - Ce n'est pas le résultat du calcul de l'estimation finale. \nc) 11 personne-heures - Ce n'est pas le résultat du calcul de l'estimation finale. \n<b>d) 10 personne-heures (Correct)\nDans la méthode d'estimation à trois points, l'effort final (E) est calculé à l'aide de la formule suivante :\nE = (optimiste + 4 * plus probable + pessimiste) / 6\n\nE = (2 + (4 * 11) + 14) / 6\nE = 50 / 6\nE = 10 personne-heures</b>"
      },
      q33: {
        en: "Test TC 001 must come first, followed by TC 002, to satisfy dependencies. Afterwards, TC 003 to satisfy priority and then TC 004, followed by TC 005. \n\nThus: \n<b>a) Is correct</b> \nb) Is not correct \nc) Is not correct \nd) Is not correct",
        fr: "<b>a) TC 003 (Correct) \nLe test TC 001 doit être exécuté en premier, suivi de TC 002, pour satisfaire les dépendances. Ensuite, TC 003 doit être exécuté pour tenir compte de la priorité, puis TC 004 et enfin TC 005.</b> \nb) TC 005 - TC 005 dépend de l'exécution réussie de TC 002, il ne peut donc pas être exécuté en troisième position.\nc) TC 002 - TC 002 doit être exécuté en deuxième position, pas en troisième.\nd) TC 001 - TC 001 doit être exécuté en première position, pas en troisième."
      },
      q34: {
        en: "Considering: \n• Usability testing is in Q3 (1 - C) \n• Component testing is in Q1 (2 - A) \n• Functional testing is in Q2 (3 - B) \n• Reliability testing is in Q4 (4 - D) \n\nThus: \n<b>a) Is correct</b> \nb) Is not correct \nc) Is not correct \nd) Is not correct",
        fr: "<b>a) 1C, 2A, 3B, 4D (Correct) \n• Test d'utilisabilité (1C) : Le test d'utilisabilité se concentre sur l'expérience utilisateur et critique la facilité d'utilisation du produit final. Il appartient donc au quadrant Q3 (orienté métier, critique du produit). \n• Test de composants (2A) : Le test de composants se concentre sur la vérification des unités de code individuelles. Il s'agit d'une activité de support technique pour l'équipe de développement et appartient donc au quadrant Q1 (orienté technologie, supportant l'équipe de développement). \n• Test fonctionnel (3B) : Le test fonctionnel vise à garantir que les fonctionnalités répondent aux exigences. Il s'agit d'une activité de support métier pour l'équipe de développement et appartient donc au quadrant Q2 (orienté métier, supportant l'équipe de développement). \n• Test de fiabilité (4D) : Le test de fiabilité évalue la capacité du système à fonctionner de manière cohérente pendant une période donnée. Il critique la maturité technique du produit et appartient donc au quadrant Q4 (orienté technologie, critique du produit).</b> \nb) 1D, 2A, 3C, 4B - Le test d'utilisabilité ne critique pas la technologie (D).\nc) 1C, 2B, 3D, 4A - Le test de composants supporte l'équipe de développement (A) et non la critique (D). Le test de fiabilité critique la technologie (D) et non le métier (B).\nd) 1D, 2B, 3C, 4A - Similaire aux justifications de b) et c)."
      }, 
      q35: {
        en: "a) Is not correct. We do not accept the risk; concrete actions are proposed \nb) Is not correct. No contingency plans are proposed \n<b>c) Is correct. The proposed actions are related to testing, which is a form of risk mitigation</b> \nd) Is not correct. Risk is not transferred but mitigated",
        fr: "a) Acceptation du risque - L'analyse propose des actions concrètes pour réduire le risque, on ne l'accepte donc pas. \nb) Plan de contingence - Aucun plan de contingence n'est proposé. Un plan de contingence décrit les actions à entreprendre si le risque se réalise. \n<b>c) Atténuation des risques (Correct)\nLes actions proposées (tests de performance et tests d'acceptation) visent à identifier et résoudre les problèmes de performances avant la mise en production, ce qui réduit l'impact potentiel du risque. Il s'agit donc d'une mesure d'atténuation des risques.</b> \nd) Transfert de risque - Le risque n'est pas transféré, il est atténué. L'atténuation des risques consiste à prendre des mesures pour réduire la probabilité ou l'impact du risque."
      },
      q36: {
        en: "a) Is not correct. Acceptance criteria are the conditions used to decide whether the user story is ready. They cannot show work progress \nb) Is not correct. Defect reports inform about the defects. They do not show work progress \nc) Is not correct. Test completion report can be created after the iteration is finished, so it will not show the progress continuously within an iteration \nd)<b> Is correct</b>. Burndown charts are a graphical representation of work left to do versus time remaining. They are updated daily, so they can continuously show the work progress",
        fr: "a) Critères d'acceptation - Les critères d'acceptation sont les conditions utilisées pour décider si une user story est terminée. Ils ne peuvent pas montrer l'avancement des travaux.\nb) Rapport de défauts - Les rapports de défauts informent sur les anomalies identifiées. Ils ne montrent pas l'avancement des travaux.\nc) Rapport de fin de test - Le rapport de fin de test peut être créé une fois l'itération terminée, il ne montrera donc pas l'avancement continu du travail au sein d'une itération.\n<b>d) Burndown chart (Correct)\nLes burndown charts sont une représentation graphique du travail restant à faire par rapport au temps restant. Ils sont mis à jour quotidiennement, ce qui permet de visualiser en continu l'avancement des travaux.</b>"
      },
      q37: {
        en: "a) Is not correct. Traceability is the relationship between two or more work products, not between different versions of the same work product \nb) Is not correct. Maintenance testing is about testing changes; it is not related closely to versioning \n<b>c) Is correct. To support testing, configuration management may involve the version control of all test items</b> \nd) Is not correct. Requirements engineering is the elicitation, documentation, and management of requirements; it is not closely related to test script versioning ",
        fr: "a) Gestion de la traçabilité - La traçabilité est la relation entre deux ou plusieurs produits de travail, et non entre différentes versions du même produit de travail.\nb) Tests de maintenance - Les tests de maintenance consistent à tester les modifications apportées au logiciel. Ils ne sont pas étroitement liés à la gestion des versions. \n<b>c) Gestion de la configuration (Correct)\nLa gestion de la configuration, pour les besoins des tests, peut inclure le contrôle de version de tous les éléments de test, y compris les scripts de test automatisés. La création d'une nouvelle version du script de test permet de conserver l'historique des modifications et de garantir la traçabilité des tests par rapport aux exigences.</b>\nd) Ingénierie des exigences - L'ingénierie des exigences consiste à extraire, documenter et gérer les exigences. Elle n'est pas étroitement liée au versioning des scripts de test."
      },
      q38: {
        en: "a) Is not correct. The expected result is “the application should accept the provided input and create the user”. The actual result is “The application hangs up after entering “Test input. $ä””. \nb) Is not correct. There is a reference to the test case and to the related requirement and it states that the defect is rejected. Also, the defect status would not be very helpful for the developers \n<b>c) Is correct. We do not know in which test environment the anomaly was detected, and we also do not know which application (and its version) is affected</b> \nd) Is not correct. The defect report states that the anomaly is urgent, that it is a global issue (i.e., many, if not all, test administration accounts are affected) and states the impact is high for business stakeholders",
        fr: "a) Résultat attendu et résultat réel - Le rapport de test mentionne que le résultat attendu est 'l'application devrait accepter l'entrée fournie et créer l'utilisateur' et que le résultat réel est 'L'application se bloque après avoir saisi « Test input: $ä »'. \nb) Références et état du défaut - Le rapport de test fait référence au cas de test TC-1305 et à l'exigence associée REQ-0012. De plus, il indique que le défaut est rejeté. Cependant, l'état du défaut (rejeté) n'est pas une information critique pour les développeurs à ce stade ; ils doivent d'abord comprendre comment reproduire le problème. \n<b>c) Environnement de test et élément de test (Correct) \nLe rapport de test ne précise pas dans quel environnement de test l'anomalie a été détectée (par exemple, environnement de développement, de test de qualification système, etc.). De plus, il ne précise pas quelle version de l'application est affectée. Ces informations sont essentielles pour que les développeurs puissent tenter de reproduire l'anomalie et la corriger.</b> \nd) Priorité et sévérité - Le rapport de test indique que la correction est urgente et que l'impact est élevé pour les parties prenantes métiers."
      },
      q39: {
        en: "a) Is not correct. Test monitoring involves the ongoing checking of all activities and comparison of actual progress against the test plan. Test control involves taking the actions necessary to meet the test objectives of the test plan. No test data are prepared during these activities. \nb) Is not correct. Test analysis includes analysis of the test basis to identify test conditions and prioritize them. Test data are not prepared during this activity. \n<b>c) Is correct. Test design and implementation can both include the identification, creation or acquisition of the testware necessary for test execution (e.g., test data).</b> \nd) Is not correct. Test completion activities occur at project milestones (e.g., release, end of iteration, test level completion), so it is too late for preparing test data.",
        fr: "a) Surveillance et contrôle des tests - La surveillance des tests implique la vérification continue de toutes les activités et la comparaison de l'avancement réel par rapport au plan de test. Le contrôle des tests consiste à prendre les mesures nécessaires pour atteindre les objectifs de test définis dans le plan de test. Aucune préparation de données de test n'est effectuée pendant ces activités. \nb) Analyse et conception des tests - L'analyse des tests comprend l'analyse de la base de test pour identifier les conditions de test et les prioriser. La conception des tests comprend l'élaboration des conditions de test en cas de test et autres éléments de test. Les données de test ne sont pas préparées pendant ces activités.\n<b>c) Implémentation et exécution des tests (Correct)\nLa mise en œuvre des tests comprend la création ou l'acquisition des éléments de test nécessaires à l'exécution des tests (par exemple, les données de test). Les outils de préparation de données aident à automatiser et à simplifier cette tâche en générant des ensembles de données de test réalistes et conformes aux exigences.</b> \nd) Achèvement des tests - Les activités d'achèvement des tests se produisent aux jalons du projet (par exemple, publication, fin d'itération, achèvement du niveau de test). Il est donc trop tard pour préparer les données de test."
      },
      q40: {
        en: "a) Is not correct. Test automation does not introduce unknown regressions in production \n<b>b) Is correct. Wrong allocation of effort to maintain testware is a risk</b> \nc) Is not correct. Test tools must be selected so that they and their testware can be relied upon \nd) Is not correct. The primary goal of test automation is to reduce manual testing. So, this is a benefit, not a risk ",
        fr: "a) Introduction de régressions inconnues en production - L'automatisation des tests en soi n'introduit pas de régressions inconnues en production. Cependant, des scripts de test mal conçus ou mal maintenus peuvent entraîner des régressions.\n<b>b) Allocation insuffisante des efforts de maintenance des éléments de test.\nLa mauvaise allocation des efforts pour maintenir les logiciels est un risque</b> \nc) Fiabilité insuffisante des outils de test et des éléments de test associés - Les outils de test et les éléments de test associés doivent être choisis et conçus pour être fiables. Un risque est présent si les outils ou les éléments de test ne sont pas fiables. \nd) Réduction du temps alloué aux tests manuels - La réduction du temps alloué aux tests manuels est généralement un avantage de l'automatisation des tests, et non un risque. L'automatisation permet de libérer des ressources pour d'autres activités de test, comme les tests exploratoires."
      },
      qb1: {
        en : "a) Is not correct. It is often possible to use dynamic testing to cause a test object to fail in ways that could never be achieved by the users, such as by using fault injection. However, if the failure can never occur with real end users, then identifying it is not especially valuable as testing is ultimately aimed at improving the work product for the end users. Spending time testing for failures that cannot occur with real users is not an efficient use of a tester's time \nb) Is not correct. Static testing in the form of static analysis is used by developers to identify defects in their program code earlier than can be achieved through dynamic testing. Note, however, that static testing (and static analysis) is used to detect defects, not failures, which are found by dynamic testing. Thus it is the use of the term'failures' that makes this an incorrect option \nc) Is not correct. Static analysis directly detects anomalies in code, which may be defects, and this is normally for the developer, not the customer. The provision of evidence for release by the use of static analysis of elements that provide no output is nonsense \n<b>d) Is correct. Reviews are a form of static testing that can be applied from the very start of the software development lifecycle and are used to find defects that can be removed before subsequent development activities waste effort on faulty requirements. If the defects are not detected and removed early on, then when the defect is found derived work products, such as the design and code, will need to be changed as they were based on faulty requirements</b>",
        fr: "a) Les tests dynamiques peuvent être utilisés pour provoquer des défaillances des objets de test d'une manière impossible pour les utilisateurs, par exemple en injectant des erreurs. Cependant, si la défaillance ne peut jamais se produire avec de vrais utilisateurs finaux, son identification n'est pas particulièrement utile car les tests visent finalement à améliorer le produit de travail pour les utilisateurs finaux. Passer du temps à tester des défaillances qui ne peuvent pas se produire avec des utilisateurs réels n'est pas une utilisation efficace du temps d'un testeur.\nb) Les tests statiques sous forme d'analyse statique sont utilisés par les développeurs pour identifier les anomalies dans leur code source plus tôt que ce qui est possible avec les tests dynamiques. Cependant, il convient de noter que les tests statiques (et l'analyse statique) sont utilisés pour détecter des anomalies, pas des défaillances, qui sont découvertes par des tests dynamiques. C'est donc l'utilisation du terme 'défaillances' qui rend cette option incorrecte.\nc) L'analyse statique détecte directement les anomalies dans le code, qui peuvent être des défauts, et cela s'adresse normalement au développeur, pas au client. Fournir des preuves pour la mise en production en utilisant l'analyse statique d'éléments qui ne fournissent aucune sortie n'a pas de sens.\n<b>d) Les revues augmentent la qualité des spécifications d'exigences et réduisent le nombre de modifications nécessaires aux produits de travail dérivés (Correct)</b>"
      },
      qb2: {
        en : "a) Is not correct. QA concentrates on process improvement and implementation, using a preventive approach to avoid errors and defects, while testing is a form of QC that is used to detect defects <b>\nb) Is correct. QC aims to achieve appropriate levels of quality by focusing on identifying and correcting product defects. Testing is a significant part of QC and helps to uncover these defects</b> \nc) Is not correct. Although testing is a significant part of QC and helps to uncover defects, other (non-testing) techniques utilized in QC include formal methods like model checking and proof of correctness, as well as simulation and prototyping \nd) Is not correct. QA concentrates on process improvement and implementation, using a preventive approach to avoid errors and defects, while testing is a form of QC that is used to detect defects",
        fr: "a) N'est pas correct. L'assurance qualité se concentre sur l'amélioration et la mise en œuvre des processus, en utilisant une approche préventive pour éviter les erreurs et les défauts, tandis que les tests sont une forme de contrôle qualité utilisée pour détecter les défauts \n<b>b) Est correct. Le contrôle qualité vise à atteindre des niveaux de qualité appropriés en se concentrant sur l'identification et la correction des défauts du produit. Les tests constituent une partie importante du contrôle qualité et aident à découvrir ces défauts.</b>\nc) N'est pas correct. Bien que les tests constituent une partie importante du contrôle qualité et aident à découvrir les défauts, d'autres techniques (non liées aux tests) utilisées dans le contrôle qualité incluent des méthodes formelles telles que la vérification des modèles et la preuve d'exactitude, ainsi que la simulation et le prototypage.\nd) N'est pas correct. L'assurance qualité se concentre sur l'amélioration et la mise en œuvre des processus, en utilisant une approche préventive pour éviter les erreurs et les défauts, tandis que les tests sont une forme de contrôle qualité utilisée pour détecter les défauts."
      },
      qb3: {
        en : "The exhaustive testing is impossible principle is concerned with the fact that it is not feasible to test every possible variation of test inputs in all different circumstances, except in trivial cases. Instead, testing utilizes test techniques, test case prioritization, and risk-based testing to sample from the set of possibilities and focus testing efforts. \n\na) Is not correct. The principle states that it is not feasible to test everything except in trivial cases. Testing everything would require testing every possible variation of test inputs in all different circumstances, which is generally infeasible as there will be a practically infinite number. Testing every possible specified output will not address this problem as the relationship between inputs and specified outputs can be different for each test object. Sometimes there may be a practically infinite number of possible specified outputs (e.g., when there are several variables representing real numbers), whereas at other times there may be just two specified outputs, such as with a single variable that can be either true or false \nb) Is not correct. The principle states that it is not feasible to test every possible variation of test inputs in all different circumstances. This is because for non-trivial systems there is a practically infinite number. Therefore, in practice, documenting all possible test input variations would be impractical as it would take an infinite length of time \nc) Is not correct. Starting testing as early as possible with reviews and other static testing approaches will not address the problem of there being too many possible test cases. The 'early testing saves time and money' principle is concerned with fixing defects early on to prevent the occurrence of subsequent defects in derived work products, thereby reducing costs and the likelihood of failures \n<b>d) Is correct. The use of equivalence partitioning and boundary value analysis to generate test cases is one way to address the principle as these test techniques provide a systematic way to derive a finite subset of all possible test cases</b>",
        fr: "Le principe « les tests exhaustifs sont impossibles » s'intéresse au fait qu’il n’est pas possible de tester toutes les variations possibles des entrées de test dans toutes les circonstances différentes, sauf dans les cas triviaux. Au lieu de cela, les tests utilisent des techniques de test, la priorisation des cas de test et des tests basés sur les risques pour échantillonner l'ensemble des possibilités et concentrer les efforts de test. \n\na) N'est pas correct. Le principe stipule qu'il n'est pas possible de tout tester sauf dans les cas triviaux. Tester tout nécessiterait de tester toutes les variations possibles des entrées de test dans toutes les circonstances différentes, ce qui est généralement irréalisable car il y en aura un nombre pratiquement infini. Tester toutes les sorties spécifiées possibles ne résoudra pas ce problème car la relation entre les entrées et les sorties spécifiées peut être différente pour chaque objet de test. Parfois, il peut y avoir un nombre pratiquement infini de sorties spécifiées possibles (par exemple, lorsqu’il y a plusieurs variables représentant des nombres réels), alors qu'à d'autres moments, il peut n'y avoir que deux sorties spécifiées, comme avec une seule variable qui peut être vraie ou fausse. \nb) N'est pas correct. Le principe stipule qu'il n'est pas possible de tester toutes les variations possibles des entrées de test dans toutes les circonstances différentes. En effet, pour les systèmes non triviaux, il en existe un nombre pratiquement infini. Par conséquent, dans la pratique, la documentation de toutes les variations possibles des entrées de test serait impraticable car cela prendrait un temps infini \nc) N'est pas correct. Commencer les tests le plus tôt possible avec des révisions et d'autres approches de tests statiques ne résoudra pas le problème du trop grand nombre de cas de test possibles. Le principe «les tests précoces permettent d'économiser du temps et de l'argent» consiste à corriger les défauts dès le début pour éviter l'apparition de défauts ultérieurs dans les produits de travail dérivés, réduisant ainsi les coûts et la probabilité d'échecs \n<b>d) Est correct. L'utilisation du partitionnement d'équivalence et de l'analyse des valeurs limites pour générer des cas de test est une façon d'aborder le principe car ces techniques de test fournissent un moyen systématique de dériver un sous-ensemble fini de tous les cas de test possibles</b>"
      },
      qb4: {
        en : "<b>a) Is correct. Test design involves using test conditions to create test cases and other necessary testware, such as test data requirements and test charters for exploratory testing. Test environment requirements are also specified, including the necessary infrastructure and tools</b> \nb) Is not correct. Test execution involves executing test cases (as part of test procedures), however it does not directly cover the other testware mentioned in the question, such as test data requirements, test environment requirements and test conditions \nc) Is not correct. Test analysis is used to identify the features that require testing. The test basis is analyzed and defined as test conditions, which are then prioritized along with related risks. While this activity involves working with test conditions, it does not cover the other testware mentioned in the question, such as test data requirements, test environment requirements and test cases \nd) Is not correct. Test implementation includes the generation of test procedures, such as manual and automated test scripts, which are created from test cases and may be assembled into test suites. Test procedures are prioritized and arranged in a test execution schedule. Test data is created, and the test environment built, and its set up verified. While this activity involves explicitly working with test cases, and may use test data requirements and test environment requirements to create test data and the test environment, it does not cover test conditions",
        fr: "<b>a) Est correct. La conception des tests implique l'utilisation de conditions de test pour créer des cas de test et d'autres tests nécessaires, tels que les exigences en matière de données de test et les chartes de test pour les tests exploratoires. Les exigences en matière d'environnement de test sont également spécifiées, y compris l'infrastructure et les outils nécessaires</b>\nb) Exécution des tests - L'exécution des tests consiste à exécuter les cas de test (dans le cadre des procédures de test), mais elle ne couvre pas directement les autres éléments de test mentionnés dans la question, tels que les exigences relatives aux données de test, les exigences relatives à l'environnement de test et les conditions de test. \nc) Analyse des tests - L'analyse des tests permet d'identifier les fonctionnalités qui nécessitent d'être testées. La base de test est analysée et définie comme des conditions de test, qui sont ensuite priorisées en fonction des risques associés. Bien que cette activité implique de travailler avec des conditions de test, elle ne couvre pas les autres éléments de test mentionnés dans la question, tels que les exigences relatives aux données de test, les exigences relatives à l'environnement de test et les cas de test. \nd) Implémentation des tests - L'implémentation des tests comprend la création de procédures de test, telles que des scripts de test manuels et automatisés, qui sont créés à partir de cas de test et peuvent être regroupés en suites de test. Les procédures de test sont priorisées et organisées dans un calendrier d'exécution des tests. Les données de test sont créées, l'environnement de test est construit et sa configuration est vérifiée. Bien que cette activité implique explicitement de travailler avec des cas de test et puisse utiliser les exigences relatives aux données de test et les exigences relatives à l'environnement de test pour créer des données de test et l'environnement de test, elle ne couvre pas les conditions de test."
      },
      qb5: {
        en: "a) Is not correct. The organization's marketing team is unlikely to perform much testing (although in some organizations they may be involved with acceptance testing), so their average level of experience (most of which would be in marketing) is not likely to impact how testing is performed for a given test object \nb) Is not correct. The level of knowledge of users that a new system is being built for them is unlikely to affect how testing is performed. Any user involvement that could affect how testing is performed is more likely to be as a result of decisions made by the testers, customer and project manager \n<b>c) Is correct. The number of years' experience of the members of the performance testing team will help to determine the capabilities and knowledge (e.g., of different tools and defect types) that the team members will apply when they are testing</b> \nd) Is not correct. The organizational structure of the different end users (who may be varied) will change between users. So, it may not even be known when the application is being tested, and the end user's organizational structure can thus have little effect on how the testing is performed ",
        fr: "a) Le niveau d'expérience moyen de l'équipe marketing de l'organisation - Il est peu probable que l'équipe marketing de l'organisation effectue beaucoup de tests (bien que dans certaines organisations, elle puisse être impliquée dans les tests d'acceptation). Par conséquent, son niveau d'expérience moyen (principalement en marketing) ne devrait pas avoir d'impact sur la façon dont les tests sont effectués pour un objet de test donné. \nb) La connaissance des utilisateurs qu'un nouveau système est en cours de développement pour eux - Le niveau de connaissance des utilisateurs qu'un nouveau système est en cours de développement pour eux ne devrait pas avoir d'impact sur la façon dont les tests sont effectués. Toute implication des utilisateurs pouvant affecter la façon dont les tests sont effectués est plus susceptible d'être le résultat de décisions prises par les testeurs, le client et le chef de projet.\n<b>c) est correct. Le nombre d'années d'expérience des membres de l'équipe de tests de performance aidera à déterminer les capacités et les connaissances (par exemple, de différents outils et types de défaut) que les membres de l'équipe appliquent lorsqu'ils testeront</b> \nd) La structure organisationnelle des utilisateurs finaux - La structure organisationnelle des différents utilisateurs finaux (qui peuvent être variés) changera d'un utilisateur à l'autre. Il est donc possible qu'elle ne soit même pas connue au moment du test de l'application. La structure organisationnelle des utilisateurs finaux a donc peu d'influence sur la façon dont les tests sont effectués."
      },
      qb6: {
        en: "a) Is not correct. Traceability between the mitigated risks and passing test cases provides little information, because to be mitigated (by testing) the risks would need to have a corresponding passing test case. To be able to assess residual risk, traceability between all risks and test results needs to be available, so that the risks that do not have a corresponding passing test can be identified as the residual risks \n<b>b) Is correct. Traceability between user requirements and test execution results provides an indication of which user requirements have been tested and so provides a means of measuring project progress (in the context of testing) against business goals</b> \nc) Is not correct. It is not clear that failing test cases provide an indication of tester skills any more than passing test cases. It would partly depend on the test objective (e.g., building confidence or causing failures). Also, such measurement of testers based on passing and failing test cases can be counter-productive as it could cause the testers to optimize their testing based on that metric rather than the test objective \nd) Is not correct. Traceability between the identified risks and written test conditions provides a means of determining which further test conditions need to be written. Determining which risks are worth testing is part of risk management, and risk mitigation in particular",
        fr: "a) La traçabilité entre les risques atténués et les cas de test réussis fournit peu d'informations. En effet, pour être atténués (par des tests), les risques devraient avoir un cas de test correspondant réussi. Pour pouvoir évaluer le risque résiduel, la traçabilité entre tous les risques et les résultats des tests doit être disponible, afin que les risques qui n'ont pas de cas de test correspondant réussi puissent être identifiés comme des risques résiduels.\n<b>b) La traçabilité entre les exigences des utilisateurs et les résultats d'exécution des tests permet de mesurer l'avancement du projet par rapport aux objectifs commerciaux (Correct)</b> \nc) Il n'est pas évident que les cas de test en échec fournissent une indication des compétences des testeurs plus que les cas de test réussis. Cela dépendrait en partie de l'objectif du test (par exemple, renforcer la confiance ou provoquer des échecs). De plus, une telle mesure des testeurs basée sur les cas de test réussis et échoués peut être contre-productive car elle pourrait amener les testeurs à optimiser leurs tests en fonction de cette mesure plutôt que de l'objectif du test. \nd) La traçabilité entre les risques identifiés et les conditions de test écrites permet de déterminer quelles conditions de test supplémentaires doivent être écrites. Déterminer quels risques valent la peine d'être testés fait partie de la gestion des risques, et plus particulièrement de l'atténuation des risques."
      },
      qb7: {
        en: "a) Is not correct. Strong communication skills, active listening, and teamwork abilities enable a tester to interact effectively with all stakeholders, however a deep knowledge of a variety of computer games that allowed them to get on well with one developer is not an example of a generic skill useful to testers \n<b>b) Is correct. Domain knowledge that can be used to understand and communicate with end-users and business representatives is one of the generic skills required by testers. A tester with experience as a pilot would make them better able to appreciate the acceptance criteria for the helicopter control system</b> \nc) Is not correct. Although programming skills could be considered as technical knowledge which can increase efficiency when utilizing some test tools, it is unlikely that these skills would improve their communication with business analysts \nd) Is not correct. Although thoroughness, attention to detail, curiosity, and a methodical approach to identifying hard-to-find defects are all useful generic skills for testers, it is doubtful they would be generating test cases prior to starting exploratory testing. This is because one of the main tenets of exploratory testing is that the test cases are generated during the testing, not scripted in advance ",
        fr: "a) Des compétences solides en communication, une écoute active et un esprit d'équipe permettent à un testeur d'interagir efficacement avec toutes les parties prenantes. Cependant, une connaissance approfondie de divers jeux vidéo qui lui a permis de s'entendre avec un développeur n'est pas un exemple de compétence générique utile aux testeurs. \n<b>b) L'ancien pilote d'hélicoptère devenu testeur était mieux à même de comprendre les critères d'acceptation du système de contrôle de l'hélicoptère (Correct)</b> \nc) Bien que les compétences en programmation puissent être considérées comme des connaissances techniques pouvant accroître l'efficacité lors de l'utilisation de certains outils de test, il est peu probable que ces compétences améliorent la communication avec les analystes métier. \nd) La minutie, le souci du détail, la curiosité et une approche méthodique pour identifier les défauts difficiles à trouver sont toutes des compétences génériques utiles pour les testeurs. Cependant, il est peu probable qu'ils génèrent des cas de test avant de commencer un test exploratoire. En effet, l'un des principes fondamentaux du test exploratoire est que les cas de test sont générés pendant le test, et non pas scriptés à l'avance."
      },
      qb8: {
        en: "a) Is not correct. The whole-team approach allows any team member with the requisite skills and knowledge to undertake any task, however that does not mean that team members can take on any role at any time. Typically, they only take on roles in which they are competent, and there is no suggestion that every team member can do every role \nb) Is not correct. The whole-team approach applies to how a single team (typically in Agile software development) works; it does not cover how multiple teams are supposed to work on larger projects, and it does not suggest that only one ''whole'' team is needed for a complete project \nc) Is not correct. The whole-team approach does not expect every team member to be involved in every important decision. For instance, there is no need for the business representative (i.e. the Product Owner) to be involved in every technical decision that does not affect the business outcome and implementing such an approach would unnecessarily slow down the team's progress \n<b>d) Is correct. By leveraging the diverse skill sets of each team member most effectively, the whole-team approach fosters superior team dynamics, promotes robust communication and collaboration, and generates a team synergy that benefits the entire project</b>",
        fr: "a) L'approche par équipe entière permet à tout membre de l'équipe disposant des compétences et des connaissances requises d'entreprendre n'importe quelle tâche. Toutefois, cela ne signifie pas que les membres de l'équipe peuvent assumer n'importe quel rôle à tout moment. En général, ils n'assument que des rôles pour lesquels ils sont compétents, et rien ne suggère que chaque membre de l'équipe puisse assumer tous les rôles.\nb) L'approche par équipe entière s'applique à la façon dont travaille une seule équipe (généralement dans le développement agile de logiciels). Elle ne traite pas de la façon dont plusieurs équipes sont censées travailler sur des projets plus importants, et elle ne suggère pas qu'une seule équipe ''entière'' soit nécessaire pour un projet complet.\nc) L'approche par équipe entière ne suppose pas que tous les membres de l'équipe soient impliqués dans chaque décision importante. Par exemple, il n'est pas nécessaire que le représentant de l'entreprise (c'est-à-dire le propriétaire du produit) soit impliqué dans toutes les décisions techniques qui n'affectent pas le résultat commercial. La mise en œuvre d'une telle approche ralentirait inutilement la progression de l'équipe. \n<b>d) est correct. En tirant parti des divers ensembles de compétences de chaque membre de l'équipe le plus efficacement, toute l'approche en équipe favorise la dynamique d'équipe supérieure, favorise une communication et une collaboration robustes et génère une synergie d'équipe qui profite à l'ensemble du projet</b>"
      },
      qb9: {
        en: "a) Is not correct. In agile software development, deliverables are produced in each iteration, and the frequent delivery of increments necessitates extensive regression testing. Although some (or all) of this regression testing may be automated, the regression testing (automated or not) cannot be replaced by system test automation \n<b>b) Is correct. If a sequential development model is used, then early in the lifecycle no code is available for execution, and so during this time static testing (e.g., reviews) is performed. Later in the lifecycle, when code is available for execution, dynamic testing is possible. Note, however, that preparation for dynamic testing will often occur early in any software development lifecycle</b> \nc) Is not correct. If an iterative development model, like agile software development, is used, then component tests may well be used for regression testing for each iteration. In which case, there is a strong argument for automating these component tests, which will have to be run frequently, and there is unlikely to be a strong argument for developers performing these component tests manually \nd) Is not correct. In most incremental development models, deliverables are produced in each increment, requiring both static and dynamic testing at all test levels for each increment delivered ",
        fr: "a) En agile, des livrables sont produits à chaque itération, et la livraison fréquente d'incréments nécessite des tests de régression approfondis. Bien qu'une partie (ou la totalité) de ces tests de régression puisse être automatisée, l'automatisation des tests système ne peut pas remplacer les tests de régression (automatisés ou non). \n<b>b) Si un modèle de développement séquentiel est utilisé, les tests dynamiques sont généralement limités à une phase ultérieure du cycle de vie (Correct)</b>\nc) Si un modèle de développement itératif, comme le développement agile, est utilisé, les tests unitaires peuvent alors être utilisés pour les tests de régression à chaque itération. Dans ce cas, il est fortement recommandé d'automatiser ces tests unitaires, qui devront être exécutés fréquemment. Il est peu probable qu'il soit pertinent que les développeurs effectuent ces tests unitaires manuellement.\nd) Dans la plupart des modèles de développement incrémental, des livrables sont produits à chaque incrément, ce qui nécessite des tests statiques et dynamiques à tous les niveaux de test pour chaque incrément livré."
      },
      qb10: {
        en: "a) Is not correct. Testers should review work products as soon as drafts are available to enable early testing as part of a shift-left approach. If they waited until the next development phase, then unnecessary development (and test) work could be started on unreviewed, flawed work products \n<b>b) Is correct. Testers should review work products as soon as drafts are available to enable early testing as part of a shift-left approach</b> \nc) Is not correct. Testers typically review work products that form the test basis as part of test analysis, not before test analysis and design \nd) Is not correct. Testers should review work products as soon as drafts are available to enable early testing as part of a shift-left approach. Waiting until they are published means that any defects that could be found by tester review will be in the published document ",
        fr: "a) Attendre la phase de développement suivante pour examiner les produits du travail ne suit pas une approche de 'shift-left'. Cela signifie que des travaux de développement (et de test) inutiles pourraient être lancés sur des produits du travail non examinés et comportant des défauts. Les testeurs doivent examiner les produits du travail dès que des brouillons sont disponibles pour permettre des tests précoces. \n<b>b) est correct. Les testeurs doivent consulter les produits de travail dès que les brouillons sont disponibles pour permettre des tests précoces dans le cadre d'une approche de shift-left</b> \nc) Généralement, les testeurs examinent les produits du travail qui constituent la base de test dans le cadre de l'analyse des tests, et non pas avant l'analyse et la conception des tests. \nd) Attendre la publication des produits du travail pour les examiner signifie que tout défaut pouvant être identifié par les testeurs se retrouvera dans le document publié. Les testeurs doivent examiner les produits du travail dès que des brouillons sont disponibles pour permettre des tests précoces."
      },
      qb11: {
        en: "<b>a) Is correct. Test-Driven Development (TDD) is a well-known example of a test-first approach to development</b>\nb) Is not correct. Coverage-Driven Development is not a correct example of a test-first approach to development\nc) Is not correct. Quality-Driven Development is not a correct example of a test-first approach to development\nd) Is not correct. Feature-Driven Development is not an example of a testfirst approach to development, but is, instead, an agile software development methodology based around delivering features (as opposed to user stories in Scrum)",
        fr: "<b>a) est correct. Le développement axé sur les tests (TDD) est un exemple bien connu d'une approche de développement axée sur les tests</b>\nb) Le développement piloté par la couverture ne constitue pas un exemple d'approche de développement basée sur les tests en premier.\nc) Le développement piloté par la qualité ne constitue pas un exemple d'approche de développement basée sur les test en premier.\nd) Le développement piloté par les fonctionnalités n'est pas un exemple d'approche de développement basée sur les tests en premier. Il s'agit plutôt d'une méthodologie de développement agile basée sur la livraison de fonctionnalités (par opposition aux user stories dans Scrum)."
      },
      qb12: {
        en: "a) Is not correct. DevOps enhances testing in several ways, such as by providing fast feedback on code quality, automated regression testing that minimizes regression risk, and promoting a shift-left approach with high-quality code submission and component tests. This is largely provided through continuous integration, where the developers submit component (unit) tests with their new code, which must pass for the code to be admitted to the build. Therefore, developers do need to complete component testin\nb)<b>Is correct. DevOps enhances testing in several ways, such as by providing fast feedback on code quality, automated regression testing that minimizes regression risk, and promoting a shift-left approach with high-quality code submission and component tests</b> \nc)Is not correct. DevOps enhances testing in several ways, such as by providing fast feedback on code quality, automated regression testing that minimizes regression risk, and promoting a shift-left approach with high-quality code submission and component tests. Testers do not attempt to treat developers and operations equally by spending more time on release testing, although a shift-right approach to testing (testing in production) may well be used\nd)Is not correct. Automated processes like continuous integration/continuous delivery (CI/CD) in DevOps facilitate stable test environments and reduce the need for manual testing, however, there is a risk of overlooking the importance of manual testing, especially from a user's perspective ",
        fr: "a)DevOps améliore les tests de plusieurs manières, par exemple en fournissant un retour d'information rapide sur la qualité du code, des tests de régression automatisés qui minimisent le risque de régression, et en promouvant une approche 'shift-left' avec une soumission de code de haute qualité et des tests unitaires. Cela est largement possible grâce à l'intégration continue, où les développeurs soumettent des tests unitaires avec leur nouveau code, lesquels doivent être réussis pour que le code soit intégré à la build. Par conséquent, les développeurs doivent effectuer des tests unitaires.\nb)<b>La réponse est correcte. DevOps améliore les tests de plusieurs façons, notamment en en fournissant un retour d'information rapide sur la qualité du code, en automatisant les tests de régression de régression automatisés qui minimisent le risque de régression, et en promouvant une approche 'shift-left' avec des tests de composants et des soumissions de code de haute qualité. la soumission d'un code de haute qualité et des tests de composants</b>\nc)DevOps améliore les tests de plusieurs manières, par exemple en fournissant un retour d'information rapide sur la qualité du code, des tests de régression automatisés qui minimisent le risque de régression, et en promouvant une approche 'shift-left' avec une soumission de code de haute qualité et des tests unitaires. Les testeurs n'essaient pas de traiter les développeurs et les opérations sur un pied d'égalité en consacrant plus de temps aux tests de mise en production, même si une approche 'shift-right' des tests (tests en production) peut être utilisée.\nd)Les processus automatisés comme l'intégration continue/livraison continue (CI/CD) dans DevOps facilitent la stabilité des environnements de test et réduisent le besoin de tests manuels. Cependant, il existe un risque de négliger l'importance des tests manuels, surtout du point de vue de l'utilisateur."
      },
      qb13: {
        en: "a)<b>Is correct. System testing examines the behavior and capabilities of the complete system and covers non-functional testing of quality characteristics, which includes security testing. This type of testing is often performed by an independent test team based on system specifications</b>\nb)Is not correct. System integration testing examines the interfaces with other systems and external services\nc)Is not correct. Beta testing is a type of acceptance testing performed at an external site by roles outside the development organization\nd)Is not correct. Component integration testing involves testing the (interfaces and) interactions between components of a system, such as the user interface and database",
        fr: "a)<b>La réponse est correcte. Les tests de système examinent le comportement et les capacités du système complet et couvrent les tests non fonctionnels de la qualité. du système complet et couvre les tests non fonctionnels des de qualité, ce qui inclut les tests de sécurité. Ce type de test est souvent effectué par une équipe de test indépendante sur la base des spécifications du système</b>\nb)Le test d'intégration du système examine les interfaces avec d'autres systèmes et services externes.\nc)Le test bêta est un type de test d'acceptation effectué sur un site externe par des personnes extérieures à l'équipe de développement.\nd)Le test d'intégration de composants consiste à tester les interactions (et les interfaces) entre les composants d'un système, tels que l'interface utilisateur et la base de données."
      },
      qb14: {
        en: "a)Is not correct. Regression tests increase in number as the project progresses, as new regression tests are typically required as changes are made to the system. Similarly, the number of confirmation tests also typically increases as the project progresses as new confirmation tests are needed for each fix made to a system\nb)Is not correct. It is the other way round. Confirmation tests are created and run when the test object is fixed, and regression tests are (ideally) run whenever the test object is enhanced (changed) \nc)Is not correct. Confirmation testing verifies that a defect has been fixed correctly and so is concerned with testing changes to the test object. However, regression testing ensures that changes (including changes to the operational environment) do not have negative effects on unchanged software and so does not check that the operational environment remains unchanged \nd)<b>Is correct. Regression testing ensures that changes do not have negative effects on unchanged software. Confirmation testing verifies that a defect has been fixed - and so is concerned with changed code</b>",
        fr: "a)Faux. Le nombre de tests de régression augmente généralement à mesure que le projet avance, car de nouveaux tests de régression sont généralement nécessaires lorsque des modifications sont apportées au système. De même, le nombre de tests de confirmation augmente également en général à mesure que le projet avance, car de nouveaux tests de confirmation sont nécessaires pour chaque correction apportée au système.\nb)Faux. C'est l'inverse. Les tests de confirmation sont créés et exécutés lorsque l'objet du test est corrigé, tandis que les tests de régression sont (idéalement) exécutés chaque fois que l'objet du test est amélioré (modifié).\nc)Faux. Les tests de confirmation vérifient qu'un défaut a été corrigé correctement et s'intéressent donc aux modifications apportées à l'objet du test. Cependant, les tests de régression garantissent que les modifications (y compris les modifications apportées à l'environnement opérationnel) n'ont pas d'effets négatifs sur les logiciels inchangés et ne vérifient donc pas si l'environnement opérationnel reste inchangé.\nd)<b>La réponse est correcte. Les tests de régression permettent de s'assurer que les modifications n'ont pas d'effets négatifs sur les logiciels inchangés. Les tests de confirmation vérifient qu'un défaut a été corrigé - et concernent donc le code modifié.</b>"
      },
      qb15: {
        en: "a) Is not correct. A lack of usability provided through the user interface can be detected through a review using a suitable checklist, but the lack of usability can also be identified by getting several typical users to dynamically test the user interface and provide feedback on its usability\n<b>b)Is correct. A code review can detect code that cannot be reached by any path, however dynamic tests can only exercise reachable code and cannot determine that code cannot be reached without running every possible combination of inputs and input states, which is impractical for real code</b>\nc)Is not correct. Poor response times for most of the expected users are difficult to determine without executing the code (i.e., by static testing), so in this situation dynamic testing could find a defect, but static testing is unlikely to find it\nd)Is not correct. A review of the code by someone who is aware of the required features could detect that the required features had not been implemented in the code, and dynamic testing could also be used to determine that these required features had not been implemented ",
        fr: "a)Un manque de convivialité de l'interface utilisateur peut être détecté par un examen à l'aide d'une liste de contrôle appropriée, mais il peut également être identifié en demandant à plusieurs utilisateurs types de tester dynamiquement l'interface utilisateur et de fournir un retour d'information sur sa convivialité.\nb)<b>Est correct. Une revue de code peut détecter le code qui ne peut être atteint par aucun chemin, mais les tests dynamiques ne peuvent exercer que le code atteignable et ne peuvent déterminer que le code ne peut être atteint sans exécuter toutes les combinaisons possibles d'entrées et d'états d'entrée, ce qui n'est pas pratique pour le code réel</b>\nc)Les temps de réponse insuffisants pour la plupart des utilisateurs attendus sont difficiles à déterminer sans exécuter le code (c'est-à-dire par des tests statiques). Ainsi, dans cette situation, les tests dynamiques pourraient révéler un défaut, mais les tests statiques ne le pourront probablement pas\nd)Un examen du code par une personne connaissant les fonctionnalités requises pourrait permettre de détecter que ces fonctionnalités n'ont pas été implémentées dans le code. Les tests dynamiques pourraient également être utilisés pour déterminer que ces fonctionnalités requises n'ont pas été implémentées."
      },
      qb16: {
        en: "a)Is not correct. The feedback is from stakeholders (e.g., business representative, end user), not from developers, so this feedback is not likely to inform managers which developers are more or less productive\nb)Is not correct. Early and frequent feedback from stakeholders is not used by project managers to prioritize how they interact with the different stakeholders\nc)<b>Is correct. Obtaining feedback from stakeholders early and often in the software development process can be highly beneficial as it facilitates early communication of potential quality issues, can prevent misunderstandings about requirements, and ensures that any changes in stakeholder requirements are understood and implemented sooner</b>\nd)Is not correct. Early and frequent feedback can prevent the development of a product that does not meet stakeholder needs, and results in costly rework and missed deadlines, so, ideally there should be no delay. Also, the feedback is from stakeholders (not to them), which includes the end users, so the end users providing feedback will not aid the end users' understanding ",
        fr: "a)Le feedback provient des parties prenantes (par exemple, représentant de l'entreprise, utilisateur final), et non des développeurs. Par conséquent, il est peu probable qu'il permette aux responsables de savoir quels développeurs sont plus ou moins productifs.\nb)Le feedback précoce et fréquent des parties prenantes n'est pas utilisé par les chefs de projet pour prioriser la façon dont ils interagissent avec les différentes parties prenantes.\nc)<b>Obtenir un feedback des parties prenantes tôt et souvent dans le processus de développement logiciel peut être très bénéfique car cela facilite la communication précoce des problèmes de qualité potentiels, peut éviter les malentendus sur les exigences et garantit que tout changement dans les exigences des parties prenantes est compris et mis en œuvre plus rapidement.</b>\nd)Un feedback précoce et fréquent peut empêcher le développement d'un produit qui ne répond pas aux besoins des parties prenantes, ce qui entraîne des retouches coûteuses et des délais manqués. Idéalement, il ne devrait donc pas y avoir de retard. De plus, le feedback provient des parties prenantes (et non pas à elles), ce qui inclut les utilisateurs finaux. Ainsi, le feedback fourni par les utilisateurs finaux ne les aidera pas à comprendre la situation."
      },
      qb17: {
        en: "Considering each of the listed task descriptions: \n1. The quality characteristics to be evaluated and the exit criteria are selected - (Planning (C): Defining the review scope, purpose, work product to be reviewed, quality characteristics to be evaluated, areas of focus, exit criteria, supporting information such as standards, effort, and timeframes.) \n2. Everyone has access to the work product - (Review initiation (B): Ensuring all participants have access to the work product and necessary resources, and clarifying their roles and responsibilities.) \n3. Anomalies are identified in the work product - (Individual review (A): Evaluating the work product's quality, identifying and logging anomalies, recommendations, and questions using review techniques like checklist-based and scenario-based reviewing.) \n4. Anomalies are analyzed and discussed - (Communication and analysis (D): Analyzing and discussing each anomaly, determining its status, ownership, and required actions, and making review decisions, normally in a meeting. This could include determining the need for a follow-up review.)\n\nThus:\na)Is not correct\nb)Is not correct\nc)Is not correct\nd)<b>Is correct. The correct match is: 1C, 2B, 3A, 4D</b>",
        fr: "En examinant chacune des descriptions de tâches énumérées :\n1. Les caractéristiques de qualité à évaluer et les critères de sortie sont sélectionnés. - (Planification (C) : Définition du champ d'application de l'examen, de son objectif, du produit de travail à examiner, des caractéristiques de qualité à évaluer, des domaines d'intérêt, des critères de sortie, des informations justificatives telles que les normes, l'effort et les délais.)\n2. Tout le monde a accès au produit de travail. - (Lancement de l'examen (B) : S'assurer que tous les participants ont accès au produit de travail et aux ressources nécessaires, et clarifier leurs rôles et responsabilités.)\n3. Des anomalies sont identifiées dans le produit de travail. - (Examen individuel (A) : Évaluation de la qualité du produit de travail, identification et enregistrement des anomalies, des recommandations et des questions à l'aide de techniques d'examen comme l'examen basé sur une liste de contrôle et l'examen basé sur un scénario.)\n4. Les anomalies sont analysées et discutées. - (Communication et analyse (D) : Analyse et discussion de chaque anomalie, détermination de son statut, de son propriétaire et des actions requises, et prise de décisions d'examen, normalement lors d'une réunion. Cela peut inclure la détermination de la nécessité d'un examen de suivi.)\n\nAnsi :\na)N'est pas correct\nb)N'est pas correct\nc)N'est pas correct\nd)<b>Est correct. La correspondance correcte est : 1C, 2B, 3A, 4D</b>"
      },
      qb18: {
        en: "Considering each of the listed roles: \n1. Scribe (or Recorder) - responsible for gathering feedback from reviewers and documenting review information, such as decisions made, and any new anomalies identified during the review meeting. (Records review information, such as decisions and new anomalies found during the review meeting - B) \n2. Review Leader - responsible for overseeing the review process, such as selecting the review team members, scheduling review meetings, and ensuring that the review is completed successfully. (Takes overall responsibility for the review such as organizing when and where the review will take place - D) \n3. Facilitator (or Moderator) - responsible for ensuring that the review meetings run effectively, including managing time, mediating discussions, and creating a safe environment where everyone can voice their opinions freely. (Ensures the effective running of review meetings and the setting up of a safe review environment - A) \n4. Manager - responsible for deciding what needs to be reviewed and allocating resources, such as staff and time, for the review. (Decides what is to be reviewed and provides resources, such as staff and time for the review - C)\n\nThus:a)Is not correct\nb)Is not correct\nc)<b>Is correct. The correct match is: 1B, 2D, 3A, 4C</b>\nd)Is not correct",
        fr: "En examinant chacun des rôles énumérés : \n1. Scribe (ou Secrétaire de séance) - responsable de recueillir les commentaires des examinateurs et de documenter les informations relatives à l'examen, telles que les décisions prises et les nouvelles anomalies identifiées pendant la réunion d'examen. (Enregistre les informations relatives à l'examen, telles que les décisions et les nouvelles anomalies identifiées pendant la réunion d'examen - B) \n2. Responsable de revue - responsable de la supervision du processus d'examen, notamment de la sélection des membres de l'équipe d'examen, de la planification des réunions d'examen et de la garantie de la bonne conduite de l'examen. (Assume la responsabilité globale de l'examen, y compris l'organisation du lieu et du moment de l'examen - D) \n3. Faciltateur - responsable de la bonne tenue des réunions d'examen, y compris la gestion du temps, la médiation des discussions et la création d'un environnement sûr où chacun peut exprimer son opinion librement. (Garantit le bon déroulement des réunions d'examen et la mise en place d'un environnement d'examen sûr - A) \n4. Manager - Le manager de décider de ce qui doit être examiné et d'allouer des ressources, telles que le personnel et le temps nécessaire à l'examen. (Décide de ce qui doit être examiné et fournit des ressources, telles que le personnel et le temps nécessaire à l'examen - C)\n\nAinsi : \na)N'est pas correct\nb)N'est pas correct\nc)<b>Est correct. La correspondance correcte est : 1B, 2D, 3A, 4C</b>\nd)N'est pas correct"
      },
      qb19: {
        en: "a)Is not correct. Decision table testing is a black-box test technique, so it is specification-based, not structure-based – the test cases are not based on the decisions in the source code. In branch testing, the test cases are derived from knowledge of the control flow of the test object\nb)Is not correct. Anticipation of potential defects is used in error guessing (an experience-based test technique), not in branch testing (a structurebased technique). In decision table testing, the test cases are derived from the specification that describes the business logic\nc)Is not correct. If a test case is based on the knowledge of the control flow of the test object, it is a white-box test technique. Decision table testing is typically based on an analysis of business logic, so it is a black-box test technique. In branch testing, test cases are not derived from the specification - this would make it a black-box test technique. Branch testing is a white-box test technique, where test cases are derived based on the source code structure\nd)<b>Is correct. Decision table testing is a black-box test technique, so it is based on an analysis of the specified behavior of the test object without reference to its internal structure. Therefore, the test cases are independent of how the software is implemented. Branch testing is awhite-box test technique, so test cases are based on an analysis of the test object's internal structure and processing. As the test cases are dependent on how the software is designed and coded, they can only be created after the design or implementation of the test object</b>",
        fr: "a)Faux. Les tests par table de décision sont une technique de test black-box, ils sont donc basés sur les spécifications et non sur la structure. Les cas de test ne sont pas basés sur les décisions du code source. Dans les tests par branche, les cas de test sont dérivés de la connaissance du flux de contrôle de l'objet de test.\nb)Faux. L'anticipation de défauts potentiels est utilisée dans le 'error guessing' (une technique de test basée sur l'expérience), et non dans les tests par branche (une technique basée sur la structure). Dans les tests par table de décision, les cas de test sont dérivés de la spécification qui décrit la logique métier.\nc)Faux. Si un cas de test est basé sur la connaissance du flux de contrôle de l'objet de test, il s'agit d'une technique de test white-box. Les tests par table de décision sont généralement basés sur une analyse de la logique métier, il s'agit donc d'une technique de test black-box. Dans les tests par branche, les cas de test ne sont pas dérivés de la spécification - cela en ferait une technique de test black-box. Les tests par branche sont une technique de test white-box, où les cas de test sont dérivés de la structure du code source.\nd)<b>La réponse est correcte. Le test de table de décision est une technique de test boîte noire, c'est-à-dire qu'il est basé sur une analyse du comportement spécifié de l'objet de test sans référence à sa structure interne. Par conséquent, les cas de test sont indépendants de la manière dont le logiciel est implémenté. Le test de branche est une technique de test boîte blanche, les cas de test sont donc basés sur une analyse de la structure interne et du traitement de l'objet de test. Comme les cas de test dépendent de la façon dont le logiciel est conçu et codé, ils ne peuvent être créés qu'après la conception ou l'implémentation de l'objet de test.</b>"
      },
      qb20: {
        en: "a)<b>Is correct. 19 covers the “no discount” partition, 20 covers the “50% discount” partition, and 30 covers the “10% discount” partition. These three values cover all three of the valid equivalence partitions</b>\nb)Is not correct. 11 and 12 cover the “no discount” partition, while 20 covers the “50% discount” partition, so covering two of the three valid equivalence partitions\nc)Is not correct. 1 covers the “no discount” partition, while 10 and 50 cover the “10% discount” partition. The “50% discount” partition is not covered, so overall two of the three valid equivalence partitions are covered\nd)Is not correct. 29 and 31 cover the “no discount” partition, while 10 and 30 cover the “10% discount” partition. The “50% discount” partition is not covered, so overall two of the three valid equivalence partitions are covered",
        fr: "a)<b>Est correct. 19 couvre la partition 'pas de remise' , 20 couvre la partition 'remise de 50%', et 30 couvre la partition 'remise de 10%'. Ces trois valeurs couvrent les trois partitions d'équivalence valides.</b>\nb)Faux. 11 et 12 couvrent la partition 'pas de remise', tandis que 20 couvre la partition 'remise de 50%', ne couvrant ainsi que deux des trois partitions d'équivalence valides.\nc)Faux. 1 couvre la partition 'pas de remise', tandis que 10 et 50 couvrent la partition 'remise de 10%'. La partition 'remise de 50%' n'est pas couverte, donc au total, deux des trois partitions d'équivalence valides sont couvertes\nd)Faux. 29 et 31 couvrent la partition 'pas de remise', tandis que 10 et 30 couvrent la partition 'remise de 10%'. La partition 'remise de 50%' n'est pas couverte, donc au total, deux des trois partitions d'équivalence valides sont couvertes."
      },
      qb21: {
        en: "The domain for the password length has three equivalence partitions:\n• passwords too short {0, 1, …, 4, 5}\n• passwords OK {6, 7, …, 11, 12}\n• passwords too long {13, 14, …}\nTo achieve full coverage for 3-value BVA we need to test the following values:\n0, 1, 4, 5, 6, 7, 11, 12, 13, 14.\nSince 2-value BVA is already covered, this means that we have already tested the passwords of length:\n0, 5, 6, 12 and 13.\nThis means that the additional lengths that need to be covered to move from 2-value to 3-value are: \n1, 4, 7, 11 and 14.\n\nThus: \na)Is not correct\nb)Is not correct\nc)Is not correct\nd)<b>Is correct</b>",
        fr: "Le domaine de la longueur du mot de passe comporte trois partitions d'équivalence :\n• Mots de passe trop courts {0, 1, ..., 4, 5}\n• Mots de passe corrects {6, 7, ..., 11, 12}\n• Mots de passe trop longs {13, 14, ...}\nPour obtenir une couverture complète en analyse des valeurs limites à 3 valeurs, nous devons tester les valeurs suivantes :\n0, 1, 4, 5, 6, 7, 11, 12, 13, 14.\nÉtant donné que l'analyse des valeurs limites à 2 valeurs est déjà couverte, cela signifie que nous avons déjà testé les mots de passe de longueur :\n0, 5, 6, 12 et 13.\nPar conséquent, les longueurs supplémentaires qui doivent être couvertes pour passer de l'analyse à 2 valeurs à l'analyse à 3 valeurs sont :\n1, 4, 7, 11 et 14.\n\nAinsi\na)N'est pas correct\nb)N'est pas correct\nc)N'est pas correct\nd)<b>Est correct</b>"
      },
      qb22: {
        en: "There are five columns in the decision table. Each test case covers one of them. \nTC1 and TC2 both cover Rule 4 \nTC3 and TC4 both cover Rule 2 \nTC5 covers Rule 5 \nSo, these five test cases cover three out of five columns, achieving a coverage of (3/5)*100% = 60%. Therefore, option b) is the CORRECT option. \n\nThus: a)Is not correct\nb)<b>Is correct</b>\nc)Is not correct\nd)Is not correct",
        fr: "La table de décision comporte cinq colonnes. Chaque cas de test couvre l'une d'entre elles. l'une d'entre elles.\nTC1 et TC2 couvrent tous deux la règle 4\nTC3 et TC4 couvrent tous deux la règle 2\nTC5 couvre la règle 5\nCes cinq cas de test couvrent donc trois colonnes sur cinq, ce qui donne une couverture de (3/5)*100% = 60%. couverture de (3/5)*100% = 60%. Par conséquent, l'option b) est l'option CORRECTE. \n\nAinsi :\na)N'est pas correct\nb)<b>Est correcte</b>\nc)N'est pas correct\nd)N'est pas correct"
      },
      qb23: {
        en: "Let us refer to the transitions with E1, …, E5 as in the picture. The variable N denotes the number of elements currently stored. Each “Add” event increases it by 1, and each “Remove” event decreases it by 1. Notice, that when the “Add” event occurs while being in the NOT FULL state, the state changes to FULL only if N=2. If N<2, the system stays in the NOT FULL state. If N=0, no “Remove” action is possible. Similarly, if N=3, no “Add” action is possible. \nTest a) can be written as E1, E3, E3, E2, E4 (so covers 4 out of 5 valid transitions, achieving 80% valid transitions coverage). \nTest b) is infeasible, because after the first three “Add” actions the system is in the FULL state and there is no valid transition going from FULL triggered by the “Add” event. After the first three transitions only 60% of valid transitions coverage is achieved. \nTest c) can be written as E1, E2, E4, E5, E3 (so covers 5 out of 5 valid transitions, achieving 100% valid transitions coverage). \nTest d) can be written as E1, E2, E4, E5, E4 (so covers 4 out of 5 valid transitions, achieving 80% valid transitions coverage).\n\nThus: \na)Is not correct\nb)Is not correct\nc)<b>Is correct</b>\nd)Is not correct",
        fr: "Désignons les transitions par E1, ..., E5 comme dans l'image. La variable N représente le nombre d'éléments actuellement stockés. Chaque événement 'Add' l'augmente de 1 et chaque événement 'Remove' le diminue de 1. Il est important de noter que lorsque l'événement 'Add' se produit alors que le système est dans l'état PAS PLEIN, l'état ne passe à PLEIN que si N=2. Si N<2, le système reste dans l'état PAS PLEIN. Si N=0, aucune action 'Remove' n'est possible. De même, si N=3, aucune action 'Add' n'est possible.\nTest a) peut s'écrire E1, E3, E3, E2, E4 (couvre donc 4 transitions valides sur 5, atteignant une couverture de 80 % des transitions valides).\nTest b) est irréalisable, car après les trois premières actions 'Add', le système est dans l'état PLEIN et il n'y a pas de transition valide partant de PLEIN déclenchée par l'événement 'Add'. Après les trois premières transitions, seulement 60 % de couverture des transitions valides sont atteints.\nTest c) peut s'écrire E1, E2, E4, E5, E3 (couvre donc 5 transitions valides sur 5, atteignant une couverture de 100 % des transitions valides).\nTest d) peut s'écrire E1, E2, E4, E5, E4 (couvre donc 4 transitions valides sur 5, atteignant une couverture de 80 % des transitions valides).\n\nAinsi :\na)N'est pas correct\nb)N'est pas correct\nc)<b>Est correct</b>\nd)N'est pas correct"
      },
      qb24: {
        en: "a)Is not correct. Coverage is always defined as the percentage of the covered elements. Therefore, it cannot exceed 100%\nb)<b>Is correct. If the statements executed by T1 and T2 were disjoint, the coverage of the test suite {T1, T2} would be 105%, which is impossible (see answer a). Therefore, at least 5% of executable statements must have been executed by both T1 and T2</b>\nc)Is not correct. Statement coverage does not tell us anything about the number of non-executable statements in the code\nd)Is not correct. Even if a test suite achieves full statement coverage, this does not imply achieving full branch coverage ",
        fr: "a)Faux. La couverture est toujours définie comme le pourcentage d'éléments couverts. Par conséquent, elle ne peut pas dépasser 100 %.\nb)<b>Vrai. Si les instructions exécutées par T1 et T2 étaient disjointes, la couverture de la suite de tests {T1, T2} serait de 105 %, ce qui est impossible (voir réponse a). Par conséquent, au moins 5 % des instructions exécutables doivent avoir été exécutées à la fois par T1 et T2.</b>\nc)Faux. La couverture d'instructions ne nous dit rien sur le nombre d'instructions non exécutables dans le code.\nd)Faux. Même si une suite de tests atteint une couverture d'instructions complète, cela ne signifie pas qu'elle atteint une couverture complète des branches"
      },
      qb25: {
        en: "Branch testing is a white-box test technique in which the coverage items are branches. A branch is a transfer of control between two nodes in the control flow graph, which shows the possible sequences in which source code statements are executed in the test object. Each transfer of control can be either unconditional (i.e., straight-line code) or conditional (i.e., a decision outcome). Coverage is measured as the number of branches exercised by the test cases divided by the total number of branches, and is expressed as a percentage.\n\nThus: \na)Is not correct. A decision outcome is a conditional branch. For branch testing, X counts not only conditional, but also unconditional branches\nb)Is not correct. Branch coverage counts not only conditional, but also  unconditional branches\nc)<b>Is correct. Branch coverage is measured as the number of branches exercised by the test cases divided by the total number of branches, and is expressed as a percentage </b>\nd)Is not correct. Both X and Y count only conditional branches and do not take into account the unconditional branches",
        fr: "Les tests de branche constituent une technique de test du code où les éléments de couverture sont les branches. Une branche est un transfert de contrôle entre deux nœuds dans le graphe de flot de contrôle, qui représente les séquences possibles d'exécution des instructions du code source dans l'objet testé. Chaque transfert de contrôle peut être inconditionnel (code séquentiel) ou conditionnel (résultat d'une décision). La couverture est mesurée par le nombre de branches exécutées par les cas de test divisé par le nombre total de branches, et est exprimée en pourcentage. \n\nAnsi :\na)incorrecte. Une sortie de décision est une branche conditionnelle. Pour les tests de branche, X compte non seulement les branches conditionnelles, mais aussi les branches inconditionnelles.\nb)incorrecte. La couverture des branches compte non seulement les branches conditionnelles, mais aussi les branches inconditionnelles.\n<b>c)correcte. La couverture des branches est mesurée par le nombre de branches exécutées par les cas de test divisé par le nombre total de branches, et est exprimée en pourcentage.</b>\nd)incorrecte. X et Y comptabilisent tous les deux uniquement les branches conditionnelles et ne prennent pas en compte les branches inconditionnelles."
      },
      qb26: {
        en: "Exploratory testing is useful when there are few or inadequate specifications or there is significant time pressure on the testing. Exploratory testing is also useful to complement other more formal test techniques. Exploratory testing will be more effective if the tester is experienced, has domain knowledge and has a high degree of essential skills, like analytical skills, curiosity and creativeness. \n\nThus:\n<b>a)Is correct. Exploratory testing is useful when there are few or inadequate specifications or there is significant time pressure on the testing </b>\nb)Is not correct. Exploratory testing is not a black-box test technique\nc)Is not correct. Exploratory testing is useful when the specifications are poorly written\nd)Is not correct. Programming skills have nothing to do with exploratory testing in principle \n<b>e)Is correct. Exploratory testing will be more effective if the tester is experienced, has domain knowledge and has a high degree of essential skills, like analytical skills, curiosity and creativeness</b>",
        fr: "Les tests exploratoires sont utiles lorsqu'il existe peu ou pas de spécifications, ou que des contraintes de temps importantes pèsent sur les tests. Ils permettent également de compléter d'autres techniques de test plus formelles. Les tests exploratoires seront plus efficaces si le testeur est expérimenté, possède des connaissances du domaine et dispose d'un haut niveau de compétences essentielles, telles que la capacité d'analyse, la curiosité et la créativité.\n\nAinsi :\na)<b>correcte. Les tests exploratoires sont utiles lorsqu'il existe peu ou pas de spécifications, ou que des contraintes de temps importantes pèsent sur les tests.</b>\nb)incorrecte. Les tests exploratoires ne sont pas une technique de test en boîte noire. Ils nécessitent une interaction continue entre le testeur et l'application.\nc)incorrecte. Les tests exploratoires sont utiles lorsque les spécifications sont mal rédigées ou incomplètes. Le fait que les spécifications soient dans un langage formel n'est pas pertinent.\nd)incorrecte. Les compétences en programmation n'ont en principe rien à voir avec les tests exploratoires.\n<b>e)correcte. Les tests exploratoires seront plus efficaces si le testeur est expérimenté, possède des connaissances du domaine et dispose d'un haut niveau de compétences essentielles, telles que la capacité d'analyse, la curiosité et la créativité.</b>"
      },
      qb27: {
        en: "a) Is not correct. Checklists should contain test conditions to be verified. This is an example of an error, not a test condition; even if the tester was able to deduce some potential test conditions from the examples of errors, this error description is too general \nb) Is not correct. Checklists should not contain items that are better suited as exit criteria. This is an example of an exit criterion \nc) Is not correct. Checklists should not contain items that are too general. This is a very general item, which practically describes the goal of testing \n<b>d) Is correct. This is an example of a test condition that can be checked by a human</b>",
        fr: "a) Incorrect. Les checklists doivent contenir des conditions de test à vérifier. Il s'agit d'un exemple d'erreur, pas d'une condition de test. Même si le testeur pouvait déduire des conditions de test potentielles à partir des exemples d'erreurs, cette description d'erreur est trop générale. \nb) Incorrect. Les checklists ne doivent pas contenir d'éléments qui conviennent mieux comme critères de sortie. Il s'agit d'un exemple de critère de sortie. \nc) Incorrect. Les checklists ne doivent pas contenir d'éléments trop généraux. C'est un élément très général, qui décrit pratiquement l'objectif du test. \n<b>d) Correct. Ceci est un exemple de condition de test qui peut être vérifiée par un humain. Le testeur peut vérifier si les messages d'erreur sont écrits dans un langage compréhensible par l'utilisateur.</b>"
      },
      qb28: {
        en: "a) Is not correct. The rule-oriented format includes formats like bullet point verification lists or tabulated forms of input-output mappings, explicitly showing the rules to be followed. Given/When/Then is a scenariooriented format because it describes a scenario to be verified \n<b>b) Is correct. This is a Given/When/Then format, which is scenario-oriented</b> \nc) Is not correct. There is no 'product-oriented' format of acceptance criteria \nd) Is not correct. There is no 'process-oriented' format of acceptance criteria",
        fr: "a) Incorrect. Le format basé sur des règles comprend des formats tels que des listes de vérification à puces ou des tableaux de mappages entrées-sorties, montrant explicitement les règles à suivre. 'Étant donné/Quand/Alors' est un format basé sur des scénarios car il décrit un scénario à vérifier.\n<b>b) Correct. Il s'agit du format 'Étant donné/Quand/Alors', qui est basé sur des scénarios.</b> \nc) Incorrect. Il n'existe pas de format de critères d'acceptation 'basé sur le produit'. \nd) Incorrect. Il n'existe pas de format de critères d'acceptation 'basé sur le processus'."
      },
      qb29: {
        en: "a) Is not correct. The test case is related to viewing previous orders in the order history \nb) Is not correct. The test case is related to viewing previous orders \nc) Is not correct. The test case is related to viewing previous orders in the order history \n<b>d) Is correct. The test case is related to the registration process, which is not discussed in the user story. The user story is about viewing previous orders </b>",
        fr: "a) Correct. Bien que lié au système de commande, ce cas de test vérifie la connexion et l'accès à l'historique des commandes, ce qui est hors du user story qui se concentre uniquement sur l'affichage de l'historique des commandes. \nb) Correct. Ce cas de test vérifie la possibilité de voir les détails d'une commande spécifique, ce qui est pertinent au user story. \nc) Correct. Ce cas de test vérifie la fonctionnalité de tri de l'historique des commandes, ce qui est pertinent au user story.\n<b>d) Incorrect. Ce cas de test vérifie le processus d'inscription, qui n'est pas mentionné dans le user story. Le user story porte sur les clients enregistrés et leur accès à l'historique des commandes.</b>"
      },
      qb30: {
        en: "<b>a) Is correct. This is something that can (and should) be checked before the code is submitted to version control</b> \nb) Is not correct. This is something that can be checked after step (2) is performed, because merge conflict reporting can be done after the code is submitted and merged \nc) Is not correct. This fits better as the entry criterion for step (3) \nd) Is not correct. This fits better as the exit criterion for step (3) ",
        fr: "<b>a) Correct. L'analyse statique est un moyen automatisé d'examiner le code source pour détecter les bogues potentiels, les vulnérabilités de sécurité et les violations de codage. Idéalement, les problèmes critiques doivent être corrigés avant de soumettre le code au contrôle de version. Cela permet d'éviter de fusionner du code potentiellement cassé dans la branche de test.</b>\nb) Incorrect. La vérification des conflits de fusion peut être effectuée après l'étape (2), car le contrôle de version peut signaler les conflits une fois que le code a été soumis et fusionné. \nc) Incorrect. Le fait que les tests unitaires soient compilés et prêts à être exécutés est un meilleur critère d'entrée pour l'étape (3) car c'est à ce moment-là que les tests unitaires doivent être exécutés sur le code soumis. \nd) Incorrect. Le pourcentage de couverture d'instructions est un meilleur critère de sortie pour l'étape (3) car il indique l'étendue des tests unitaires effectués sur le code soumis."
      },
      qb31: {
        en: "The average development effort is $900,000 and the average test effort is $90,000 (calculated from the four projects). The average test-to-development effort ratio is 1:10 ($90,000 : $900,000), which means that historically, on average, the test effort is 10% of the development effort. \nSo if the development effort is estimated to be $800,000, the estimated test effort is estimated as: \n10% * $800,000 = 0.1 * $800,000 = $80,000. \n\nThus: \na) Is not correct \n<b>b) Is correct </b>\nc) Is not correct \nd) Is not correct",
        fr: "L'effort de développement moyen est de 900 000 $ et l'effort de test moyen est de 90 000 $ (calculé à partir des quatre projets). Le ratio effort de test / effort de développement moyen est de 1:10 (90 000 $ / 900 000 $), ce qui signifie qu'historiquement, en moyenne, l'effort de test représente 10 % de l'effort de développement. \nDonc, si l'effort de développement est estimé à 800 000 $, l'effort de test estimé est calculé comme suit : \n10 % * 800 000 $ = 0,1 * 800 000 $ = 80 000 $ \n\nAinsi : \na) Est incorrecte \n<b>b) Est correcte</b> \nc) Est incorrecte \nd) Est incorrecte"
      },
      qb32: {
        en: "The logical dependencies mean that for each product you have to run SEARCH → VIEW → ADD before running ORDER. You can add more products (using the same flow), before you run ORDER. Based on this, TC1 or TC2 must be executed first, otherwise no progress can be made. \nThe first priority should be given to VIEW and ADD product B, as its test cases (TC6, TC4) are assigned with higher priority. \nSo, the first 3 test to execute are TC2 -> TC4 -> TC6 \nNow we need consider whether to run TC7 and then the entire flow for product A or run the TCs for product A first. Is TC7 has lower priority than the other tests, they should be tested first. Therefore, the entire flow should be: \nTC2 -> TC4 -> TC6 -> TC1 -> TC3 -> TC5 -> TC7 \na) Is not correct. TC1 must be executed before TC3 \n<b>b) Is correct</b> \nc) Is not correct. As shown above, TC7 is the last to be executed. \nd) Is not correct. Product B must be executed before product A",
        fr: "Selon les dépendances, les tests de RECHERCHE doivent être exécutés en premier, puis les tests d'AFFICHAGE, puis les tests d'AJOUT et enfin les tests de COMMANDE. Au sein de chacun de ces groupes, l'ordre est déterminé par les priorités des cas de test. \nDonc, TC1 doit être exécuté en premier, puis TC2, ensuite TC4 suivi de TC3, et enfin TC5 en dernier. \nL'ordre d'exécution est donc : TC1, TC2, TC4, TC3, TC5. \n<b>Par conséquent, la réponse correcte est a) TC3.</b>"
      },
      qb33:{
        en: "a) Is not correct. Usability testing is business facing testing that critiques the product (Q3) \nb) Is not correct. Functional testing is business facing testing (Q2) \nc) Is not correct. User acceptance testing is business facing testing that critiques the product (Q3) \n<b>d) Is correct. Component integration testing is technology facing testing that supports the team (guides the development) (Q1)</b>",
        fr: "a) Incorrect. Le test d'utilisabilité est un test orienté métier qui critique le produit (Q3). Il évalue la facilité d'utilisation et l'adéquation du produit aux besoins des utilisateurs. \nb) Incorrect. Le test fonctionnel est un test orienté métier (Q2). Il vérifie si le produit fonctionne conformément aux exigences fonctionnelles. \nc) Incorrect. Le test d'acceptation utilisateur est un test orienté métier qui critique le produit (Q3). Il permet aux utilisateurs finaux de valider si le produit répond à leurs attentes. \n<b>d) Correct. Le test d'intégration de composants est un test orienté technologie qui supporte l'équipe (Q1). Il vérifie si les composants individuels fonctionnent correctement lorsqu'ils sont intégrés ensemble. Ce type de test aide l'équipe de développement à identifier et corriger les problèmes au plus tôt dans le cycle de développement.</b>"
      },
      qb34: {
        en: "Considering each of the listed risks and their mitigations: \n1. Long system responses (1) can be tested in performance testing (B) \n2. Changes of consumers' preferences (2) are usually out of our control, so usually we accept this risk (A) \n3. Flooding of the server room (3) can cause significant loss, so we should transfer the risk, e.g., by buying an insurance policy (D) \n4. That patients above a certain age receive inaccurate reports (4) suggests a potential boundary problem, which can be effectively detected with techniques like BVA (C) \n\nThus: \na) Is not correct \nb) Is not correct \n<b>c) Is correct. The correct combinations of risk and mitigation are: 1B, 2A, 3D and 4C</b> \nd) Is not correct",
        fr: "Examinons chaque risque et les atténuations proposées : \nTemps de réponse longs (1) : Les tests de performance (B) permettent d'identifier et de résoudre les problèmes de performances du système. Changement de préférences des consommateurs (2) : Ce type de risque est généralement hors de notre contrôle. L'acceptation du risque (A) est donc la stratégie la plus appropriée. \nInondation de la salle des serveurs (3) : Ce risque peut entraîner des pertes importantes. Le transfert de risque (D), par exemple en souscrivant une assurance, permet de minimiser l'impact financier. \nRapports inexacts pour les patients âgés (4) : Cela suggère un problème de limites. L'analyse des valeurs limites (C) est une technique de test efficace pour identifier ce genre de problème. \n<b>Par conséquent, la correspondance correcte entre les risques et les activités d'atténuation est c) 1B, 2A, 3D, 4C.</b "
      },
      qb35: {
        en: "<b>a) Is correct. Product quality metrics measure quality characteristics. Mean time to failure measures maturity, so it is a product quality metric</b> \nb) Is not correct. This is an example of a defect metric, not a product quality metric \nc) Is not correct. This is an example of a coverage metric, not a product quality metric \nd) Is not correct. This is an example of a defect metric, not a product quality metric",
        fr: "<b>a) Correct. Les mesures de la qualité du produit évaluent les caractéristiques de qualité. Le temps moyen entre les pannes (MTBF) mesure la maturité du produit, c'est donc une mesure de la qualité du produit.</b> \nb) Incorrect. Ceci est un exemple de mesure de défaut, et non de mesure de qualité du produit. \nc) Incorrect. Ceci est un exemple de mesure de couverture, et non de mesure de qualité du produit. \nd) Incorrect. Ceci est un exemple de mesure de défaut, et non de mesure de qualité du produit."
      },
      qb36: {
        en: "<b>a) Is correct. The client is in a different location and time zone, so it may be difficult to communicate face-to-face</b> \nb) Is not correct. Dashboards are usually available to any user at any time, so the difference in time zones will not be as much of a hindrance to communication as verbal, face-to-face communication \nc) Is not correct. Although the time difference between Europe and America is several hours, and this may cause some inconvenience, it's certainly not as great as with communicating face-to-face \nd) Is not correct. Video conferencing tools are a convenient means of communication. Although communication between Europe and America during working hours usually requires one party to connect in the very early or very late hours, this is not as much of an inconvenience as verbal, face-to-face communication ",
        fr: "<b>a) Correct. Le client se trouve dans un autre lieu et fuseau horaire, il peut donc être difficile de communiquer en face à face. Organiser des réunions en respectant les horaires de chacun peut être compliqué.</b> \nb) Incorrect. Les tableaux de bord sont généralement disponibles pour tout utilisateur à tout moment. La différence de fuseaux horaires ne sera donc pas un obstacle aussi important à la communication que la communication verbale en face à face. \nc) Incorrect. Bien que le décalage horaire entre l'Europe et l'Amérique soit de plusieurs heures et puisse entraîner des inconvénients, il n'est certainement pas aussi important qu'avec la communication en face à face. Des emails bien ciblés peuvent être un moyen efficace de communication. \nd) Incorrect. Les outils de visioconférence sont un moyen de communication pratique. Bien que la communication entre l'Europe et l'Amérique pendant les heures de travail nécessite généralement qu'une des parties se connecte très tôt ou très tard, ce n'est pas aussi gênant que la communication verbale en face à face."
      },
      qb37: {
        en: "<b>a) Is correct. For a complex configuration item (e.g., a test environment), CM records the items it consists of, their relationships, and versions</b> \nb) Is not correct. CM tools do not execute test cases and do not calculate coverage \nc) Is not correct. A CM tool is not a license management tool \nd) Is not correct. CM tools do not generate test data",
        fr: "<b>a) Est correcte. Pour un élément de configuration complexe (par exemple, un environnement de test), CM enregistre les éléments qui le composent, leurs relations et les versions.</b> b) N'est pas correct. Les outils de CM n'exécutent pas les cas de test et ne calculent pas la couverture. c) N'est pas correct. Un outil de CM n'est pas un outil de gestion des licences d) La réponse est incorrecte. Les outils de CM ne génèrent pas de données de test"
      },
      qb38: {
        en: "a) Is not correct. While the sentence is true, it does not provide much value for the developer \n<b>b) Is correct. From the test results it seems that the system ignores duplicates and sorts the list disregarding the repetitions. This is probably the cause of failures in TC3, TC4, TC5. Such information may help the developer to find the defect and fix it more efficiently</b> \nc) Is not correct. The system does not fail in sorting negative numbers. The problem is rather in disregarding duplicates \nd) Is not correct. The test cases TC3, TC4 and TC5 fail, but we aren't aware that the test cases have any defects",
        fr: "a) N'est pas correcte. Bien que la phrase soit vraie, elle n'apporte pas grand-chose au développeur. pour le développeur \n<b>b) Est correcte. D'après les résultats des tests, il semble que le système ignore les doublons et trie la liste sans tenir compte des répétitions. les doublons et trie la liste en ignorant les répétitions. C'est probablement la cause des échecs dans TC3, TC4, TC5. Ces informations peuvent aider le développeur à trouver le défaut et à le corriger plus efficacement.</b> \nc) N'est pas correct. Le système n'échoue pas dans le tri des nombres négatifs. Le problème se situe plutôt au niveau de la non prise en compte des doublons. \nd) N'est pas correct. Les cas de test TC3, TC4 et TC5 échouent, mais nous ne savons pas que les cas de test présentent des défauts."
      },
      qb39: {
        en: "Considering each of the listed tool categories and their descriptions:\nA. Static testing tools - support the tester in performing reviews andstatic analysis (4)\nB. Tools supporting scalability and deployment standardization - Forexample, virtual machines, containerization tools (3)\nC. DevOps tools - support the DevOps delivery pipeline, workflowtracking, automated build process(es), continuousintegration/continuous delivery (CI/CD) (1)\nD. Collaboration tools - facilitate communication (2)\n\nThus:\na) Is not correct\nb) Is not correct\n<b>c) Is correct. The correct match is: 1C, 2D, 3B, 4A</b>\nd) Is not correct",
        fr: "Examinons chaque catégorie d'outils et les descriptions correspondantes : \nA. Outils de test statique - Aident les testeurs à effectuer des revues et des analyses statiques (4). \nB. Outils supportant l'évolutivité et la standardisation du déploiement - Par exemple, les machines virtuelles et les outils de conteneurisation (3). \nC. Outils DevOps - Soutiennent le pipeline de livraison DevOps, le suivi du workflow, les processus de build automatisés et l'intégration continue/livraison continue (CI/CD) (1). \nD. Outils de collaboration - Facilitent la communication (2). \n<b>Par conséquent, la correspondance correcte est c) 1C, 2D, 3B, 4A.</b>"
      },
      qb40: {
        en: "<b>a) Is correct. Test automation can provide measures that are too complicated for humans to derive, such as white-box test coverage measures for all but the most trivial code</b> \nb) Is not correct. By using test tools the responsibility for the testing is NOT shared with the tool vendor as the vendor is not involved in the testing, and it is the tester’s responsibility. The only possible responsibility that could be assigned to the tool vendor is if the tool fails to work as expected and provides incorrect test results \nc) Is not correct. Testers still need to perform critical thinking when analyzing anomalies in the test results to determine their likely cause \nd) Is not correct. Neither testers nor tools can generate test cases simply from an analysis of the program code as the code is the implementation and provides no information on the expected results, which will need to come from another part of the test basis, such as the design specification ",
        fr: "<b>a) Correct. L'automatisation des tests peut fournir des mesures trop complexes à dériver par des humains, telles que les mesures de couverture de test en boîte blanche pour tous les codes sauf les plus triviaux.</b> \nb) Incorrect. L'utilisation d'outils de test ne partage PAS la responsabilité des tests avec le fournisseur de l'outil. Le fournisseur n'est pas impliqué dans les tests, et c'est la responsabilité du testeur. La seule responsabilité qui pourrait être attribuée au fournisseur de l'outil est si l'outil ne fonctionne pas comme prévu et fournit des résultats de test incorrects. \nc) Incorrect. Les testeurs doivent toujours faire preuve d'un esprit critique lors de l'analyse des anomalies dans les résultats des tests pour en déterminer la cause probable. \nd) Incorrect. Ni les testeurs ni les outils ne peuvent générer des cas de test simplement à partir d'une analyse du code du programme. Le code est l'implémentation et ne fournit aucune information sur les résultats attendus, qui devront provenir d'une autre partie de la base de test, telle que la spécification de conception."
      },
      qc1: {
        en: "a) Is not correct. Validating that documented requirements are met is incorrect as validation is concerned with meeting user requirements and expectations, while verification is concerned with meeting specified requirements, so this would be correct if we replaced 'validating' with 'verifying' \n<b>b) Is correct. Causing failures and identifying defects is probably the most common objective of dynamic testing</b> \nc) Is not correct. Initiating errors and identifying root causes is incorrect because testers do not initiate errors, they try to cause failures. Errors are typically made by developers (and cannot really be initiated) and result in defects, which testers attempt to identify either directly through static testing or indirectly through failures with dynamic testing. Identifying root causes is useful but is part of debugging, which is a separate activity to testing \nd) Is not correct. Verifying the test object meets user expectations is incorrect as verification is concerned with checking specified (documented) requirements are met, while validation is concerned with meeting user requirements and expectations, so this would be correct if we replaced 'verifying' with 'validating'",
        fr: "a) Incorrect. Valider que les exigences documentées sont respectées n'est pas exact. La validation vise à répondre aux besoins et aux attentes des utilisateurs, alors que la vérification vise à répondre aux exigences spécifiées. Donc, cette option serait correcte si on remplaçait « valider » par « vérifier ». \n<b>b) Correct. Provoquer des pannes et identifier les défauts est probablement l'objectif le plus courant des tests dynamiques.</b> \nc) Incorrect. Initier des erreurs et identifier les causes racines est incorrect car les testeurs n'initient pas d'erreurs, ils essaient de provoquer des pannes. Les erreurs sont généralement commises par les développeurs (et ne peuvent pas vraiment être initiées) et entraînent des défauts que les testeurs tentent d'identifier soit directement par des tests statiques, soit indirectement par des pannes avec des tests dynamiques. L'identification des causes racines est utile mais fait partie du débogage, qui est une activité distincte du test. \nd) Incorrect. Vérifier que l'objet de test répond aux attentes des utilisateurs n'est pas exact. La vérification vise à contrôler si les exigences spécifiées (documentées) sont respectées, alors que la validation vise à répondre aux besoins et aux attentes des utilisateurs. Donc, cette option serait correcte si on remplaçait « vérifier » par « valider »."
      },
      qc2: {
        en: "a) Is not correct. Dynamic testing does cause failures (from which defects can then be located and fixed). However, debugging is concerned with locating defects and fixing these defects. Therefore, debugging does not fix failures \nb) Is not correct. Both testing and debugging contribute to improving the quality of the test object, so should really both be considered positively. Debugging is generally considered to be a positive activity as it is fixing something. Dynamic testing does involve intentionally causing the test object to fail, which is why some people consider it a negative activity, but that is a very narrow view (and not one typically held by testers). Both positive and negative test cases are possible. Positive test cases check that the test object correctly performs what it is supposed to do, while negative testing checks that the test object does not do what it is not supposed to do \n<b>c) Is correct. Testing determines that defects exist either directly through observation of the defect in reviews (or by a tool in static analysis), or indirectly by causing a failure in dynamic testing. Debugging is a separate activity from testing (normally performed by developers) and is concerned with locating defects (only for dynamic testing) and fixing the defects</b> \nd) Is not correct. The causes of defects are typically human errors. Testing finds defects either directly through static testing, or indirectly by causing failures in dynamic testing, and debugging fixes defects. So, testing does not find the cause of defects and debugging does not fix the causes of defects ",
        fr: "a) Incorrect. Les tests dynamiques provoquent des pannes (à partir desquelles les défauts peuvent ensuite être localisés et corrigés). Cependant, le débogage vise à localiser les défauts et à les corriger. Par conséquent, le débogage ne corrige pas les pannes. \nb) Incorrect. Les tests et le débogage contribuent tous deux à l'amélioration de la qualité de l'objet de test, et doivent donc être considérés de manière positive. Le débogage est généralement considéré comme une activité positive car il s'agit de corriger quelque chose. Les tests dynamiques impliquent de provoquer intentionnellement la défaillance de l'objet de test, c'est pourquoi certaines personnes le considèrent comme une activité négative, mais c'est une vision très étroite (et pas celle des testeurs en général). Les cas de test positifs et négatifs sont tous deux possibles. Les cas de test positifs vérifient que l'objet de test fonctionne correctement, tandis que les tests négatifs vérifient qu'il ne fait pas ce qu'il n'est pas censé faire. \n<b>c) Correct. Les tests déterminent l'existence de défauts, soit directement par l'observation du défaut dans les revues (ou par un outil en analyse statique), soit indirectement en provoquant une panne dans les tests dynamiques. Le débogage est une activité distincte des tests (généralement effectuée par les développeurs) et vise à localiser les défauts (uniquement pour les tests dynamiques) et à les corriger.</b> \nd) Incorrect. Les causes des défauts sont généralement des erreurs humaines. Les tests trouvent des défauts, soit directement par des tests statiques, soit indirectement en provoquant des pannes dans les tests dynamiques, et le débogage corrige les défauts. Ainsi, les tests ne trouvent pas la cause des défauts et le débogage ne corrige pas les causes des défauts."
      },
      qc3: {
        en: "The ‘absence-of-defects fallacy’ is concerned with the idea that ensuring correctness in accordance with the requirements (i.e., verifying the absence of implementation defects) does not guarantee user satisfaction with the system. To address this it is also necessary to validate that the system meets users' needs and expectations, fulfills business objectives, and outperforms competing systems. \na) Is not correct. The ‘testing shows the presence, not the absence of defects’ principle explains that while testing can detect the existence of defects in the test object, it is not possible to demonstrate that there are no defects and, therefore, guarantee its correctness. Therefore, explaining that it is not possible for testing to show the absence of defects would partially address this principle, not the ‘absence-ofdefects’ fallacy \n<b>b) Is correct. By supporting the end user to perform acceptance testing it should be possible to validate that the system meets users' needs and expectations</b> \nc) Is not correct. It is not possible to ensure that no implementation defects remain in the delivered system as the ‘testing shows the presence, not the absence of defects’ principle explains that while testing can detect the existence of defects in the test object, it is not possible to demonstrate that there are no defects and, therefore, guarantee its correctness \nd) Is not correct. Modifying tests that cause no failures to ensure few defects remain is one way to address the ‘tests wear out’ principle. This principle is concerned with the idea that repeating identical tests on unaltered code is unlikely to uncover novel defects and therefore, modifying tests may be essential. This will not validate that the system meets users' needs and expectations ",
        fr: "Le « L'illusion de l'absence de défauts » s'intéresse à l'idée que garantir la justesse par rapport aux exigences (c'est-à-dire vérifier l'absence de défauts d'implémentation) ne garantit pas la satisfaction des utilisateurs vis-à-vis du système. Pour y remédier, il faut également valider que le système répond aux besoins et aux attentes des utilisateurs, qu'il atteint les objectifs commerciaux et qu'il surpasse les systèmes concurrents. a) Incorrect. Le principe « les tests montrent la présence, non l'absence de défauts » explique que si les tests peuvent détecter des anomalies dans l'objet testé, il est impossible de démontrer qu'il n'y a aucun défaut et donc de garantir sa justesse. Par conséquent, expliquer qu'il est impossible pour les tests de montrer l'absence de défauts ne répondrait que partiellement à ce principe, et non au « sophisme de l'absence de défauts ». <b>b) Correct. En aidant les utilisateurs finaux à effectuer des tests d'acceptation, il devrait être possible de valider que le système répond à leurs besoins et à leurs attentes.</b> c) Incorrect. Il est impossible de garantir qu'aucun défaut d'implémentation ne subsiste dans le système livré, car le principe « les tests montrent la présence, non l'absence de défauts » explique que si les tests peuvent détecter des anomalies dans l'objet testé, il est impossible de démontrer qu'il n'y a aucun défaut et donc de garantir sa justesse. d) Incorrect. Modifier les tests qui ne provoquent pas d'échecs pour garantir qu'il reste peu de défauts est une façon d'aborder le principe de « l'usure des tests ». Ce principe s'intéresse à l'idée que la répétition de tests identiques sur un code inchangé est peu susceptible de révéler de nouveaux défauts. Par conséquent, la modification des tests peut être essentielle. Cela ne permettra pas de valider que le système répond aux besoins et aux attentes des utilisateurs."
      },
      qc4: {
        en: "Given the following description of test analysis: \nTo identify the features that require testing, the test basis is analyzed and defined as test conditions, which are then prioritized along with related risks. The systematic identification of test conditions as coverage items often involves using test techniques both during test analysis and as part of the test design activity. \nFrom the above description, it can be seen that test techniques are often used in the test analysis and test design activities. Boundary value analysis and equivalence partitioning are test techniques. \na) Is not correct. Test implementation is not likely to involve the use of test techniques as it is mostly concerned with assembling test cases into test procedures, while test techniques create test cases \n<b>b) Is correct. Test design is likely to involve the use of test techniques to create test cases from test conditions and coverage items</b> \nc) Is not correct. Test execution is not likely to involve the use of test techniques as it is mostly concerned with executing test procedures (and so test cases), while test techniques create test cases \nd) Is not correct. Test monitoring is not likely to involve the use of test techniques. Test monitoring is mostly concerned with ongoing checks to ensure the plan is being followed, while test techniques create test cases \n<b>e) Is correct. Test analysis is likely to involve the use of test techniques to identify test conditions</b>",
        fr: "En se basant sur la description suivante de l'analyse des tests : \nPour identifier les fonctionnalités à tester, la base de test est analysée et définie sous forme de conditions de test, qui sont ensuite priorisées en fonction des risques associés. L'identification systématique des conditions de test en tant qu'éléments de couverture implique souvent l'utilisation de techniques de test à la fois pendant l'analyse des tests et dans le cadre de la conception des tests. \nD'après la description ci-dessus, on peut voir que les techniques de test sont souvent utilisées dans les activités d'analyse et de conception des tests. L'analyse des valeurs limites et le partitionnement d'équivalence sont des techniques de test. \na) Incorrect. L'implémentation des tests n'est pas susceptible d'impliquer l'utilisation de techniques de test car elle consiste principalement à assembler des cas de test en procédures de test, alors que les techniques de test permettent de créer des cas de test. \n<b>b) Correct. La conception des tests est susceptible d'impliquer l'utilisation de techniques de test pour créer des cas de test à partir de conditions de test et d'éléments de couverture.</b> \nc) Incorrect. L'exécution des tests n'est pas susceptible d'impliquer l'utilisation de techniques de test car elle consiste principalement à exécuter des procédures de test (et donc des cas de test), alors que les techniques de test permettent de créer des cas de test. \nd) Incorrect. La supervision des tests n'est pas susceptible d'impliquer l'utilisation de techniques de test. La supervision des tests consiste principalement à effectuer des vérifications continues pour s'assurer que le plan est respecté, alors que les techniques de test permettent de créer des cas de test. \n<b>e) Correct. L'analyse des tests est susceptible d'impliquer l'utilisation de techniques de test pour identifier les conditions de test.</b>"
      },
      qc5: {
        en: "Considering each of the listed test activities and their output testware: \nA. Test analysis - prioritized test conditions (4) (e.g., acceptance criteria), and defect reports for defects identified in the test basis \nB. Test design - prioritized test cases, test charters, coverage items (1), test data requirements, and test environment requirements \nC. Test implementation - test procedures, automated test scripts, test suites, test data, test execution schedule (3), and test environment elements such as stubs, drivers, simulators, and service virtualizations \nD. Test completion - test completion report, documented lessons learned, action items for improvement, and change requests (2) (as product backlog items) \n\nThus: \n<b>a) Is correct. The correct match is: 1B, 2D, 3C, 4A</b> \nb) Is not correct \nc) Is not correct \nd) Is not correct",
        fr: "Examinons chacune des activités de test et les éléments de testware produits : \nA. Analyse des tests - Conditions de test priorisées (4) (par exemple, critères d'acceptation) et rapports de défauts pour les défauts identifiés dans la base de test \nB. Conception des tests - Cas de test priorisés, chartes de test, éléments de couverture (1), exigences relatives aux données de test et exigences relatives à l'environnement de test \nC. Implémentation des tests - Procédures de test, scripts de test automatisés, suites de test, données de test, calendrier d'exécution des tests (3) et éléments d'environnement de test tels que les stubs, les drivers, les simulateurs et les virtualisations de services \nD. Achèvement des tests - Rapport d'achèvement des tests, leçons apprises documentées, éléments d'action pour l'amélioration et demandes de changement (2) (en tant qu'éléments de backlog de produit) \n\nPar conséquent : \n<b>a) Correct. L'appariement correct est : 1B, 2D, 3C, 4A</b> \nb) Incorrect. L'appariement n'est pas correct. \nc) Incorrect. L'appariement n'est pas correct. \nd) Incorrect. L'appariement n'est pas correct."
      },
      qc6: {
        en: "a) Is not correct. Although it is correct to say that in Agile software development, some of the test management tasks may be handled by the Agile team itself, the testing role is not primarily the responsibility of a single individual from outside the team. Instead the testing is more likely to be performed by various team members following the wholeteam approach \nb) Is not correct. The test management role primarily involves activities related to test planning, test monitoring and control, and test completion. So, although this statement is partially correct, it is wrong to say that the testing role is primarily responsible for test monitoring and control \n<b>c) Is correct. In Agile software development, some of the test management tasks may be handled by the Agile team itself. However, for test activities that span multiple teams within an organization, test managers outside of the development team may perform these tasks</b> \nd) Is not correct. The test management role primarily involves activities related to test planning, test monitoring and control, and test completion, while the testing role is primarily responsible for the technical and engineering aspects of testing, such as test analysis, test design, test implementation, and test execution. Thus the test management role is not normally responsible for test analysis and test design, although it is correct to say that the testing role is primarily responsible for test implementation and execution",
        fr: "a) Incorrect. Bien qu'il soit exact de dire que dans le développement logiciel Agile, certaines des tâches de gestion des tests peuvent être prises en charge par l'équipe Agile elle-même, le rôle de testeur n'est pas la responsabilité principale d'un seul individu externe à l'équipe. Au contraire, les tests sont plus susceptibles d'être effectués par différents membres de l'équipe en suivant l'approche 'équipe entière'. \nb) Incorrect. Le rôle de responsable des tests implique principalement des activités liées à la planification des tests, au suivi et au contrôle des tests, et à la réalisation des tests. Donc, bien que cette affirmation soit partiellement correcte, il est faux de dire que le rôle de testeur est principalement responsable du suivi et du contrôle des tests. \n<b>c) Correct. Dans le développement logiciel Agile, certaines des tâches de gestion des tests peuvent être prises en charge par l'équipe Agile elle-même. Cependant, pour les activités de test qui s'étendent à plusieurs équipes au sein d'une organisation, des responsables de test en dehors de l'équipe de développement peuvent effectuer ces tâches.</b> \nd) Incorrect. Le rôle de responsable des tests implique principalement des activités liées à la planification des tests, au suivi et au contrôle des tests, et à la réalisation des tests, tandis que le rôle de testeur est principalement responsable des aspects techniques et d'ingénierie des tests, tels que l'analyse des tests, la conception des tests, la mise en œuvre des tests et l'exécution des tests. Ainsi, le rôle de responsable des tests n'est normalement pas responsable de l'analyse et de la conception des tests, bien qu'il soit exact de dire que le rôle de testeur est principalement responsable de la mise en œuvre et de l'exécution des tests."
      },
      qc7: {
        en: "a) Is not correct. In the whole-team approach, testers play a vital role by sharing their testing expertise with the team and guiding product development. They collaborate with other team members to achieve the desired quality levels and work with business representatives to create acceptance tests. Testers also partner with developers to determine the optimal test strategy and automation approaches \n<b>b) Is correct. By leveraging the diverse skill sets of each team member most effectively, the whole-team approach fosters superior team dynamics, promotes robust communication and collaboration, and generates a synergistic effect that benefits the entire project</b> \nc) Is not correct. The whole-team approach allows any team member with the requisite skills and knowledge to undertake any task, thus specialist team members are not an advantage of this approach \nd) Is not correct. There is no specific guidance on the optimum size of teams using the whole-team approach, and there is no suggestion that larger teams are better",
        fr: "a) Incorrect. Dans l'approche par équipe entière, les testeurs jouent un rôle vital en partageant leur expertise en matière de test avec l'équipe et en guidant le développement du produit. Ils collaborent avec les autres membres de l'équipe pour atteindre les niveaux de qualité souhaités et travaillent avec les représentants de l'entreprise pour créer des tests d'acceptation. Les testeurs s'associent également aux développeurs pour déterminer la stratégie de test optimale et les approches d'automatisation. \n<b>b) Correct. En exploitant de la manière la plus efficace les compétences diverses de chaque membre de l'équipe, l'approche par équipe entière favorise une meilleure dynamique d'équipe, encourage une communication et une collaboration solides, et génère un effet synergique qui profite à l'ensemble du projet.</b> \nc) Incorrect. L'approche par équipe entière permet à tout membre de l'équipe disposant des compétences et des connaissances requises d'entreprendre n'importe quelle tâche. Ainsi, les membres d'équipe spécialisés ne sont pas un avantage de cette approche. \nd) Incorrect. Il n'existe pas de directives spécifiques sur la taille optimale des équipes utilisant l'approche par équipe entière, et rien ne suggère que les équipes plus grandes soient meilleures."
      },
      qc8: {
        en: "<b>a) Is correct. The primary benefit of independence in testing is that testers are more likely to identify different types of failures and defects compared to developers, due to their varied backgrounds, technical viewpoints, and potential biases, including cognitive bias. However, the main disadvantage of independence in testing is that testers may become isolated from the development team, leading to communication problems, a lack of collaboration, and potentially an adversarial relationship, with testers being blamed for delays and bottlenecks in the release process</b> \nb) Is not correct. A developer's familiarity with the code does not mean that they rarely find defects in it, instead this familiarity means they can efficiently find many defects in their own code. And, rather than developers and testers having a shared background, developers having a different background to testers is normally cited as the reason that testers and developers find different kinds of defects \nc) Is not correct. Testing can be conducted at different levels of independence, ranging from no independence for the author to very high independence for testers from outside the organization. In most projects, multiple levels of independence are utilized, with developers performing component and component integration testing, the test team performing system and system integration testing, and business representatives performing acceptance testing. So, testers can be in the developer’s team and do not need to come from outside the organization. Knowledge of the application domain will change from case-to-case and is not dependent on the level of independence \nd) Is not correct. Testing can be conducted at different levels of independence, ranging from no independence for the author to very high independence for testers from outside the organization, with testers from outside the developer’s team generally more independent than testers from within the team. However, there is more reason to believe that testers from outside the team are likely to be more isolated from the developers and so are more likely to be blamed for delays in product release ",
        fr: "<b>a) Correct. Le principal avantage de l'indépendance des tests est que les testeurs sont plus susceptibles d'identifier différents types d'échecs et de défauts par rapport aux développeurs, en raison de leurs antécédents, de leurs points de vue techniques et de leurs biais potentiels, y compris les biais cognitifs. Cependant, le principal inconvénient de l'indépendance des tests est que les testeurs peuvent devenir isolés de l'équipe de développement, ce qui entraîne des problèmes de communication, un manque de collaboration et potentiellement une relation conflictuelle, les testeurs étant blâmés pour les retards et les goulots d'étranglement dans le processus de publication.</b> \nb) Incorrect. La familiarité d'un développeur avec le code ne signifie pas qu'il trouve rarement des défauts. Au contraire, cette familiarité lui permet de trouver efficacement de nombreux défauts dans son propre code. De plus, plutôt que d'avoir un bagage commun, le fait que les développeurs et les testeurs aient des bagages différents est généralement cité comme la raison pour laquelle les testeurs et les développeurs trouvent des types de défauts différents. \nc) Incorrect. Les tests peuvent être menés à différents niveaux d'indépendance, allant d'aucune indépendance pour l'auteur à une indépendance très élevée pour les testeurs extérieurs à l'organisation. Dans la plupart des projets, plusieurs niveaux d'indépendance sont utilisés, les développeurs effectuant des tests unitaires et d'intégration des composants, l'équipe de test effectuant des tests système et d'intégration système, et les représentants métiers effectuant des tests d'acceptation. Ainsi, les testeurs peuvent faire partie de l'équipe de développement et n'ont pas besoin de venir de l'extérieur de l'organisation. La connaissance du domaine d'application variera d'un cas à l'autre et ne dépend pas du niveau d'indépendance. \nd) Incorrect. Les tests peuvent être menés à différents niveaux d'indépendance, allant d'aucune indépendance pour l'auteur à une indépendance très élevée pour les testeurs extérieurs à l'organisation. En général, les testeurs extérieurs à l'équipe de développement sont plus indépendants que ceux qui en font partie. Cependant, il est plus probable que les testeurs extérieurs à l'équipe soient plus isolés des développeurs et donc plus susceptibles d'être blâmés pour les retards de publication du produit."
      },
      qc9: {
        en: "a) Is not correct. Quality control applies to all development activities, meaning that every software development activity has a corresponding test activity. However, here we are attempting to equate test levels with development levels, and, although we know what is meant by ‘test levels’, there is no common understanding of the term 'development level' \nb) Is not correct. Every software development activity has a corresponding test activity; however test objectives are quite different. For instance, there might be a test objective of ensuring that a test object adheres to a contractual requirement that a certain type of testing must be performed before delivery. In this case there is no reason for there to be a corresponding development objective \nc) Is not correct. Quality control applies to all development activities, meaning that every software development activity has a corresponding test activity. However, the same symmetry does not apply to testing and user activities. For instance, for some systems it is difficult to even identify the end users. Also, some test activities are focused on developers (e.g., testing for ease of maintainability), which has no user aspect to it \n<b>d) Is correct. Quality control applies to all development activities, meaning that every software development activity has a corresponding test activity</b>",
        fr: "a) Incorrect. Le contrôle de la qualité s'applique à toutes les activités de développement, ce qui signifie que chaque activité de développement logiciel a une activité de test correspondante. Cependant, ici nous essayons d'assimiler les niveaux de test aux niveaux de développement, et bien que nous sachions ce que l'on entend par 'niveaux de test', il n'existe pas de compréhension commune du terme 'niveau de développement'. \nb) Incorrect. Chaque activité de développement logiciel a une activité de test correspondante ; cependant, les objectifs de test sont assez différents. Par exemple, il peut y avoir un objectif de test visant à garantir qu'un objet de test respecte une exigence contractuelle selon laquelle un certain type de test doit être effectué avant la livraison. Dans ce cas, il n'y a aucune raison d'avoir un objectif de développement correspondant. \nc) Incorrect. Le contrôle de la qualité s'applique à toutes les activités de développement, ce qui signifie que chaque activité de développement logiciel a une activité de test correspondante. Cependant, la même symétrie ne s'applique pas aux activités de test et aux activités des utilisateurs. Par exemple, pour certains systèmes, il est même difficile d'identifier les utilisateurs finaux. De plus, certaines activités de test sont centrées sur les développeurs (par exemple, les tests de facilité de maintenance), ce qui n'a aucun aspect utilisateur. \n<b>d) Correct. Le contrôle de la qualité s'applique à toutes les activités de développement, ce qui signifie que chaque activité de développement logiciel a une activité de test correspondante.</b>"
      },
      qc10: {
        en: "a) Is not correct. Component Test-Driven Development is not a correct example of a test-first approach to development \nb) Is not correct. Integration Test-Driven Development is not a correct example of a test-first approach to development \nc) Is not correct. System Test-Driven Development is not a correct example of a test-first approach to development \n<b>d) Is correct. Acceptance Test-Driven Development (ATDD) is a wellknown example of a test-first approach to development</b> ",
        fr: "a) Incorrect. Le développement piloté par les tests unitaires (Component Test-Driven Development) n'est pas un exemple correct de l'approche 'Test-First' en développement logiciel. \nb) Incorrect. Le développement piloté par les tests d'intégration (Integration Test-Driven Development) n'est pas un exemple correct de l'approche 'Test-First' en développement logiciel. \nc) Incorrect. Le développement piloté par les tests système (System Test-Driven Development) n'est pas un exemple correct de l'approche 'Test-First' en développement logiciel. \n<b>d) Correct. Le développement piloté par l'acceptation (Acceptance Test-Driven Development - ATDD) est un exemple bien connu de l'approche 'Test-First' en développement logiciel.</b>"
      },
      qc11: {
        en: "a) Is not correct. Practices involved in shift-left testing are aimed at implementing more testing activities in the early phases of the development life cycle, portraying the SDLC as moving from left to right. There is no such thing as the left-hand side of the test process \n<b>b) Is correct. Shift-left emphasizes the importance of starting testing earlier in the software development lifecycle (SDLC). Implementing shift-left testing necessitates additional training, and increased effort and costs during the early stages of the SDLC, nevertheless, overall savings should be higher</b> \nc) Is not correct. Although automated component tests and component integration tests for regression testing are generally valuable, the creation of these tests is normally the responsibility of the developers, and if a continuous integration/continuous delivery (CI/CD) approach is followed, then these tests will have been submitted with the code. In some situations the tester may automate tests for regression testing, and sometimes even for component tests and component integration tests, however this is not part of a 'shift-left' approach which moves testing earlier in the SDLC \nd) Is not correct. Training testers to perform tasks early in the SDLC would support a shift-left approach by emphasizing the importance of starting testing earlier in the SDLC. However, automating more test activities to be performed later in the SDLC is not part of a 'shift-left' approach",
        fr: "a) Incorrect. Les pratiques associées aux tests 'Shift-Left' visent à mettre en œuvre davantage d'activités de test dans les phases initiales du cycle de vie du développement, en décrivant le SDLC comme allant de gauche à droite. Il n'existe pas de côté gauche du processus de test. \n<b>b) Correct. L'approche 'Shift-Left' souligne l'importance de commencer les tests plus tôt dans le cycle de vie du développement logiciel (SDLC). La mise en œuvre de tests 'Shift-Left' nécessite une formation supplémentaire, ainsi que des efforts et des coûts accrus pendant les premières étapes du SDLC. Néanmoins, les économies globales devraient être plus importantes.</b> \nc) Incorrect. Bien que les tests unitaires et les tests d'intégration de composants automatisés pour les tests de régression soient généralement utiles, la création de ces tests relève normalement de la responsabilité des développeurs. Si une approche d'intégration continue/livraison continue (CI/CD) est suivie, alors ces tests auront été soumis avec le code. Dans certains cas, le testeur peut automatiser des tests pour la régression, et parfois même pour les tests unitaires et les tests d'intégration de composants. Cependant, cela ne fait pas partie d'une approche 'Shift-Left' qui déplace les tests plus tôt dans le SDLC. \nd) Incorrect. La formation des testeurs pour effectuer des tâches en amont du SDLC soutiendrait une approche 'Shift-Left' en soulignant l'importance de commencer les tests plus tôt. Cependant, l'automatisation d'un plus grand nombre d'activités de test à effectuer plus tard dans le SDLC ne fait pas partie d'une approche 'Shift-Left'."
      },
      qc12: {
        en: "a) Is not correct. One of the purposes of retrospectives is to identify potential process improvements, which, if put into practice, should result in the quality of future outputs of the development process (test objects) being higher. So, this is likely to occur as a result of a retrospective \nb) Is not correct. A benefit of retrospectives for testing includes increased test efficiency through process improvements. So, this is likely to occur as a result of a retrospective \n<b>c) Is correct. Participants at retrospectives typically include testers, developers, architects, product owners, and business analysts, but end users are rarely invited or attend these meetings – and they are also unlikely to receive any reports from these meetings. So, it is very unlikely that they will learn and understand more about the development and test processes through retrospectives</b> \nd) Is not correct. A benefit of retrospectives for testing includes improved quality of testware (including automated test scripts) through joint reviews with developers. So, this is likely to occur as a result of a retrospective ",
        fr: "a) Incorrect. L'un des objectifs des rétrospectives est d'identifier les améliorations potentielles des processus, qui, si elles sont mises en pratique, devraient se traduire par une meilleure qualité des futurs produits du processus de développement (objets de test). C'est donc un résultat probable d'une rétrospective. \nb) Incorrect. L'un des avantages des rétrospectives pour les tests est l'amélioration de l'efficacité des tests grâce à des améliorations des processus. C'est donc un résultat probable d'une rétrospective. \n<b>c) Correct. Les participants aux rétrospectives comprennent généralement des testeurs, des développeurs, des architectes, des propriétaires de produits et des analystes commerciaux, mais les utilisateurs finaux sont rarement invités ou ne participent pas à ces réunions - et il est également peu probable qu'ils reçoivent des rapports de ces réunions. Il est donc très peu probable qu'ils en apprennent davantage sur les processus de développement et de test grâce aux rétrospectives.</b> \nd) Incorrect. L'un des avantages des rétrospectives pour les tests est l'amélioration de la qualité des logiciels de test (y compris les scripts de test automatisés) grâce à des examens conjoints avec les développeurs. C'est donc un résultat probable d'une rétrospective."
      },
      qc13: {
        en: "a) Is not correct. Component testing (also called unit testing) involves testing individual components in isolation and is mostly verification against a specification, rather than validation against user needs. However, this testing is not normally performed by testers, as developers usually carry out this testing in their development environment \nb) Is not correct. Component integration testing involves testing the interfaces and interactions between components and is mostly verification against a specification, rather than validation against user needs. However, this testing is not normally performed by testers, as developers usually carry out this testing \nc) Is not correct. System integration testing examines the interfaces with other systems and external services and is mostly verification against a specification, rather than validation against user needs. This type of testing is also most often performed by testers \n<b>d) Is correct. Acceptance testing focuses on validating that the system meets the user's business needs and is ready for deployment. Ideally, this testing is carried out by the end users</b>",
        fr: "a) Incorrect. Le test unitaire (également appelé test d'unité) consiste à tester des composants individuels de manière isolée et vise principalement la vérification par rapport à une spécification, plutôt que la validation par rapport aux besoins des utilisateurs. Cependant, ce test n'est normalement pas effectué par des testeurs, car les développeurs le réalisent habituellement dans leur environnement de développement. \nb) Incorrect. Le test d'intégration de composants consiste à tester les interfaces et les interactions entre les composants et vise principalement la vérification par rapport à une spécification, plutôt que la validation par rapport aux besoins des utilisateurs. Cependant, ce test n'est normalement pas effectué par des testeurs, car les développeurs le réalisent habituellement. \nc) Incorrect. Le test d'intégration système examine les interfaces avec d'autres systèmes et services externes et vise principalement la vérification par rapport à une spécification, plutôt que la validation par rapport aux besoins des utilisateurs. Ce type de test est également le plus souvent effectué par des testeurs. \n<b>d) Correct. Le test d'acceptation vise à valider si le système répond aux besoins métiers des utilisateurs et s'il est prêt pour le déploiement. Idéalement, ce test est effectué par les utilisateurs finaux.</b>"
      },
      qc14: {
        en: "a) Is not correct. Confirmation testing to check that the updates have resulted in a correct implementation is necessary, however, it would then be sensible to perform regression testing to ensure that no defects have been introduced or uncovered in unchanged areas of the system \n<b>b) Is correct. Confirmation testing will check that the updates have resulted in a correct implementation, and then regression testing will be used to ensure that no defects have been introduced or uncovered in unchanged areas of the system</b> \nc) Is not correct. Regression testing should be used to ensure that no defects have been introduced or uncovered in unchanged areas of the system when the update was made, however it is also necessary to perform confirmation testing that will check that the updates have resulted in a correct implementation \nd) Is not correct. Confirmation testing will check that the updates have resulted in a correct implementation, and regression testing will be used to ensure that no defects have been introduced or uncovered in unchanged areas of the system. However, when performed (i.e., when an update needs to be tested), confirmation testing precedes regression testing ",
        fr: "a) Incorrect. Un test de confirmation est nécessaire pour vérifier que les mises à jour ont conduit à une implémentation correcte. Cependant, il serait judicieux d'effectuer ensuite un test de régression pour s'assurer qu'aucun défaut n'a été introduit ou découvert dans des zones inchangées du système. \n<b>b) Correct. Le test de confirmation permettra de vérifier que les mises à jour ont conduit à une implémentation correcte, puis le test de régression permettra de s'assurer qu'aucun défaut n'a été introduit ou découvert dans des zones inchangées du système.</b> \nc) Incorrect. Un test de régression doit être utilisé pour s'assurer qu'aucun défaut n'a été introduit ou découvert dans des zones inchangées du système lors de la mise à jour. Cependant, il est également nécessaire d'effectuer un test de confirmation pour vérifier que les mises à jour ont conduit à une implémentation correcte. \nd) Incorrect. Le test de confirmation permettra de vérifier que les mises à jour ont conduit à une implémentation correcte, puis le test de régression permettra de s'assurer qu'aucun défaut n'a été introduit ou découvert dans des zones inchangées du système. Cependant, lors de son exécution (c'est-à-dire lorsqu'une mise à jour doit être testée), le test de confirmation précède le test de régression."
      },
      qc15: {
        en: "Considering each of the listed example defects: \ni. Two different parts of the design specification disagree due to the complexity of the design – this is an example of a specification defect, which includes inconsistencies, ambiguities, contradictions, omissions, inaccuracies, and duplications, which can most easily be found by static testing \nii. A response time is too long and so makes users lose patience - this is an example of a response time defect, which can only be detected in practice by executing the program and measuring the response time, which can most easily be found by dynamic testing \niii. A path in the code cannot be reached during execution - this is an example of a coding defect, which includes variables with undefined values, undeclared variables, duplicated or unreachable code, and excessive code complexity, which can most easily be found by static testing \niv. A variable is declared but never subsequently used in the program - this is an example of a coding defect, which includes variables with undefined values, undeclared variables, duplicated or unreachable code, and excessive code complexity, which can most easily be found by static testing \nv. The amount of memory needed by the program to generate a report is too high – this is an example of a performance defect, which can only be detected in practice by executing the program and measuring the memory used, which can most easily be found by dynamic testing \n\nThus: \na) Is not correct \nb) Is not correct \nc) Is not correct \n<b>d) Is correct. The correct match for static testing is i, iii, and iv</b>",
        fr: "En examinant chacun des exemples de défauts listés : \ni. Désaccord entre les parties de la spécification de conception - Il s'agit d'un exemple de défaut de spécification, qui comprend des incohérences, des ambiguïtés, des contradictions, des omissions, des inexactitudes et des redondances. Ces défauts peuvent être trouvés plus facilement par analyse statique. \nii. Temps de réponse trop long - Il s'agit d'un exemple de défaut de temps de réponse, qui ne peut être détecté que dans la pratique en exécutant le programme et en mesurant le temps de réponse. Ce type de défaut est plus facilement identifiable par analyse dynamique. \niii. Chemin inaccessible dans le code - Il s'agit d'un exemple de défaut de codage, qui comprend des variables avec des valeurs non définies, des variables non déclarées, du code dupliqué ou inaccessible, et une complexité excessive du code. Ces défauts peuvent être trouvés plus facilement par analyse statique. \niv. Variable déclarée mais jamais utilisée - Il s'agit d'un exemple de défaut de codage, qui comprend des variables avec des valeurs non définies, des variables non déclarées, du code dupliqué ou inaccessible, et une complexité excessive du code. Ces défauts peuvent être trouvés plus facilement par analyse statique. \nv. Mémoire excessive pour générer un rapport - Il s'agit d'un exemple de défaut de performance, qui ne peut être détecté que dans la pratique en exécutant le programme et en mesurant la mémoire utilisée. Ce type de défaut est plus facilement identifiable par analyse dynamique. \n\n<b>En conclusion, l'analyse statique permet d'identifier les défauts i, iii et iv.</b>"
      },
      qc16: {
        en: "<b>a) Is correct. Obtaining feedback from stakeholders early and often in the software development process can be highly beneficial. It facilitates early communication of potential quality issues, can prevent misunderstandings about requirements, and ensures that any changes in stakeholder requirements are understood and implemented sooner</b> \nb) Is not correct. The feedback is from stakeholders, and them providing feedback is unlikely to improve their understanding of their own user requirements \nc) Is not correct. Obtaining feedback from stakeholders early and often in the software development process can be highly beneficial. It facilitates early communication of potential quality issues, can prevent misunderstandings about requirements, and ensures that any changes in stakeholder requirements are understood and implemented sooner. However, because changes in requirements can be understood and implemented sooner, it does not mean that unlimited changes to requirements are encouraged \nd) Is not correct. The feedback is from stakeholders and does not cover communication to them. Communications to end users could include them being told about which requirements will not be implemented prior to release, but ideally this should not happen at all",
        fr: "<b>a) Correct. Obtenir un feedback des parties prenantes dès le début et fréquemment au cours du processus de développement logiciel peut être très bénéfique. Cela facilite la communication précoce des problèmes de qualité potentiels, peut éviter les malentendus sur les exigences et garantit que tout changement dans les exigences des parties prenantes est compris et mis en œuvre plus tôt.</b> \nb) Incorrect. Le feedback provient des parties prenantes, et le fait qu'elles en donnent ne leur permettra probablement pas de mieux comprendre leurs propres exigences d'utilisateurs. \nc) Incorrect. Obtenir un feedback des parties prenantes dès le début et fréquemment au cours du processus de développement logiciel peut être très bénéfique. Cela facilite la communication précoce des problèmes de qualité potentiels, peut éviter les malentendus sur les exigences et garantit que tout changement dans les exigences des parties prenantes est compris et mis en œuvre plus tôt. Cependant, le fait que les modifications des exigences puissent être comprises et mises en œuvre plus tôt ne signifie pas que des modifications illimitées des exigences soient encouragées. \nd) Incorrect. Le feedback provient des parties prenantes et ne couvre pas la communication avec elles. La communication avec les utilisateurs finaux pourrait inclure le fait de leur indiquer quelles exigences ne seront pas mises en œuvre avant la publication, mais idéalement cela ne devrait pas se produire du tout."
      },
      qc17: {
        en: "Considering each of the listed review types: \n1. Technical review - This type of review is performed by technically qualified reviewers and led by a moderator. The objectives are to gain consensus and make decisions on technical problems while also evaluating quality and building confidence in the work product, generating new ideas, motivating and enabling authors to improve, and detecting anomalies \n2. Informal review - The main objective is to detect anomalies. The process is not defined and does not require formal documented output \n3. Inspection - This is the most formal review type, and it follows the complete generic review process. The primary objective is to find the most anomalies, and other objectives include evaluating quality and building confidence in the work product, motivating and enabling authors to improve, and collecting metrics that can be used to enhance the software development life cycle (SDLC), including the inspection process. The author cannot act as the review leader or scribe \n4. Walkthrough - Led by the author, this type of review serves various objectives such as evaluating quality and building confidence in the work product, educating reviewers, gaining consensus, generating new ideas, motivating and enabling authors to improve, and detecting anomalies. Reviewers might perform an individual review before the walkthrough, but this is not mandatory \nA. Includes objectives such as gaining consensus, generating new ideas, and motivating authors to improve \nB. Includes objectives such as educating reviewers, gaining consensus, generating new ideas and detecting potential defects \nC. The main objective is detecting potential defects and it requires metrics collection to support process improvement \nD. The main objective is detecting potential defects and it generates no formal documented output \n\nThus: \na) Is not correct \n<b>b) Is correct.</b> \nc) Is not correct \nd) Is not correct ",
        fr: "Feedback for correct answers \n1. Revue technique - Ce type d'examen est réalisé par des examinateurs techniquement qualifiés et dirigé par un modérateur. Les objectifs sont de parvenir à un consensus et de prendre des décisions sur des problèmes techniques tout en évaluant la qualité et en renforçant la confiance dans le produit du travail, en générant de nouvelles idées, en motivant et en permettant aux auteurs de s'améliorer, et en détectant des anomalies. \n2. Revue informel - L'objectif principal est de détecter des anomalies. Le processus n'est pas défini et ne nécessite pas de document de sortie formel. \n3. Inspection - Il s'agit du type d'examen le plus formel, et il suit le processus d'examen générique complet. L'objectif principal est de trouver le plus d'anomalies possible. D'autres objectifs incluent l'évaluation de la qualité et le renforcement de la confiance dans le produit du travail, la motivation et la permission pour les auteurs de s'améliorer, et la collecte de mesures qui peuvent être utilisées pour améliorer le cycle de vie du développement logiciel (SDLC), y compris le processus d'inspection. L'auteur ne peut pas agir en tant que chef d'équipe d'examen ou scribe. \n4. Relecture technique - Dirigé par l'auteur, ce type d'examen vise divers objectifs tels que l'évaluation de la qualité et le renforcement de la confiance dans le produit du travail, la formation des examinateurs, la recherche d'un consensus, la génération de nouvelles idées, la motivation et la permission pour les auteurs de s'améliorer, et la détection d'anomalies. Les examinateurs peuvent effectuer un examen individuel avant la revue pas à pas, mais cela n'est pas obligatoire. \nEn se basant sur les objectifs décrits et le niveau de formalité, l'association la plus pertinente est : \nA. Comprend des objectifs tels que gagner du consensus, générer de nouvelles idées et motiver les auteurs à améliorer (a) \nB. L'objectif principal est de détecter les défauts potentiels et il ne génère aucune sortie documentée formelle (D) \nC. L'objectif principal est de détecter les défauts potentiels et nécessite une collection de métriques pour soutenir l'amélioration des processus (C) \nD. comprend des objectifs tels que l'éducation des examinateurs, l'obtention d'un consensus, la génération de nouvelles idées et la détection des défauts potentiels (b) \n\nAinsi: \na) n'est pas correct \n<b>b) est correct. La correspondance correcte est: 1a, 2d, 3c, 4b</b> \nc) n'est pas correct \nd) n'est pas correct"
      },
      qc18: {
        en: "a) Is not correct. To ensure successful reviews, it's important to secure management's support for the review process, however that does not mean that they should participate as reviewers \n<b>b) Is correct. To ensure successful reviews, it's important to break the work product into parts that are small enough to be reviewed in a reasonable timescale to prevent reviewers from losing focus during individual review or review meetings</b> \nc) Is not correct. To ensure successful reviews, it's important to clearly define objectives and measurable exit criteria, without evaluating participants \nd) Is not correct. To ensure successful reviews, it's important to break down the review into smaller chunks to prevent reviewers from losing focus during individual review or review meetings. So you should not plan to cover one document per review ",
        fr: "a) Incorrect. Pour garantir la réussite des revues, il est important d'obtenir le soutien de la direction pour le processus de revue. Cependant, cela ne signifie pas qu'elle doive participer en tant que réviseur. \n<b>b) Correct. Pour garantir la réussite des revues, il est important de diviser le produit de travail en parties suffisamment petites pour être examinées dans un délai raisonnable afin d'éviter que les réviseurs ne perdent leur concentration pendant l'examen individuel ou les réunions d'examen.</b> \nc) Incorrect. Pour garantir la réussite des revues, il est important de définir clairement les objectifs et les critères de sortie mesurables, sans évaluer les participants. \nd) Incorrect. Pour garantir la réussite des revues, il est important de diviser l'examen en sections plus petites afin d'éviter que les réviseurs ne perdent leur concentration pendant l'examen individuel ou les réunions d'examen. Il ne faut donc pas prévoir de couvrir un document par revue."
      },
      qc19: {
        en: "a) Is not correct. In most cases both black-box test techniques and experience-based test techniques can be used for the same test objects \nb) Is not correct. Both black-box test techniques and experience-based test techniques can be used at all test levels \n<b>c) Is correct. Black-box test techniques (also known as specification-based techniques) are based on an analysis of the specified behavior of the test object without reference to its internal structure. So, the test basis is usually a specification. Experience-based test techniques effectively use the knowledge and experience of testers for the design and implementation of test cases. This means that the tester, when designing tests, may not use the specification at all</b> \nd) Is not correct. Experience-based test techniques can detect defects that may be missed using black-box (and white-box) test techniques. Hence, experience-based test techniques are complementary to black-box test techniques and white-box test techniques and both black-box test techniques and experience-based test techniques can be used in all SDLCs",
        fr: "a) Incorrect. Dans la plupart des cas, les techniques de test en boîte noire et les techniques de test basées sur l'expérience peuvent être utilisées pour les mêmes objets de test. \nb) Incorrect. Les techniques de test en boîte noire et les techniques de test basées sur l'expérience peuvent toutes deux être utilisées à tous les niveaux de test. \n<b>c) Correct. Les techniques de test en boîte noire (également appelées techniques basées sur les spécifications) sont basées sur une analyse du comportement spécifié de l'objet de test sans référence à sa structure interne. Donc, la base du test est généralement une spécification. Les techniques de test basées sur l'expérience utilisent efficacement les connaissances et l'expérience des testeurs pour la conception et la mise en œuvre des cas de test. Cela signifie que le testeur, lors de la conception des tests, peut ne pas utiliser du tout la spécification.</b> \nd) Incorrect. Les techniques de test basées sur l'expérience peuvent détecter des défauts qui pourraient être manqués en utilisant les techniques de test en boîte noire (et en boîte blanche). Par conséquent, les techniques de test basées sur l'expérience sont complémentaires aux techniques de test en boîte noire et en boîte blanche, et les deux types de techniques peuvent être utilisées dans tous les cycles de vie du développement logiciel (SDLC)."
      },
      qc20: {
        en: "There are five equivalent partitions: \n(Input) Length: \nL1: Between 1 and 3 \nL2: 4 \nL3: above 4 \n(Input) Digits: \nD1: PIN that is all with the same digits \nD2: PIN with at least two different digits \n(Output) Two partitions: \nG1: Legal PIN (fulfils both L2 and D2) \nG2: Illegal PIN \n<b>a) Is correct. 112 covers D2, L1, G2; 1111 covers D1, L2, G2; 1234 covers D2, L2, G1; 123456 covers D2, L3, G2</b> \nb) Is not correct. It doesn’t cover L3 1 covers D1, L1, G2; 123 covers D2, L1, G2; 1111 covers D1, L2, G2; 12345 covers D2, L2, G1 \nc) Is not correct. It doesn’t cover D1 12 covers D2, L1, G2; 112 covers D2, L1, G2; 1112 covers D2, L2, G1; 11112 covers D2, L3, G2 \nd) Is not correct. It doesn’t cover D2 (and G1) 1 covers D1, L1, G2; 111 covers D1, L1, G2; 1111 covers D1, L2, G2; 11111 covers D1, L3, G2 ",
        fr: "Il existe cinq partitions équivalentes : \n(Entrée) Longueur : \nL1 : entre 1 et 3 \nL2 : 4 \nL3 : supérieur à 4 \n(Entrée) Chiffres : \nD1 : code PIN contenant tous les mêmes chiffres \nD2 : code PIN contenant au moins deux chiffres différents \n(Sortie) Deux partitions : \nG1 : code PIN légal (remplit à la fois L2 et D2) \nG2 : code PIN illégal \n<b>a) Est correct. 112 couvre D2, L1, G2 ; 1 111 couvre D1, L2, G2 ; 1 234 couvre D2, L2, G1 ; 123 456 couvre D2, L3, G2</b> \nb) N'est pas correct. Il ne couvre pas L3 1 couvre D1, L1, G2 ; 123 couvre D2, L1, G2 ; 1 111 couvre D1, L2, G2 ; 12345 couvre D2, L2, G1 \nc) N'est pas correct. Il ne couvre pas D1 12 couvre D2, L1, G2 ; 112 couvre D2, L1, G2 ; 1112 couvre D2, L2, G1 ; 11112 couvre D2, L3, G2 \nd) N'est pas correct. Il ne couvre pas D2 (et G1) 1 couvre D1, L1, G2 ; 111 couvre D1, L1, G2 ; 1111 couvre D1, L2, G2 ; 11111 couvre D1, L3, G2"
      },
      qc21: {
        en: "The equivalence partitions are: {…, 99, 100}, {101, 102, …, 198, 199}, {200, 201, …}. \nThus, there are 4 boundary values, which are: 100, 101, 199 and 200. In 2-value BVA, for each boundary value there are two coverage items (the boundary value and its closest neighbor belonging to the adjacent partition). As the closest neighbors are also boundary values in the adjacent partition, then there are just four coverage items. \n\nThus: \na) Is not correct. Only 100 and 200 are valid coverage items for 2-value BVA, so we achieve 50% coverage \nb) Is not correct. Only 100 and 200 are valid coverage items for 2-value BVA, so we achieve 50% coverage \nc) Is not correct. Only 100 and 101 are valid coverage items for 2-value BVA, so we achieve 50% coverage \n<b>d) Is correct. 101, 199 and 200 are valid coverage items for 2-value BVA, so we achieve 75% coverage</b>",
        fr: "Les partitions d'équivalence sont : {…, 99, 100}, {101, 102, …, 198, 199}, {200, 201, …}. \nPar conséquent, il y a 4 valeurs limites, qui sont : 100, 101, 199 et 200. Dans l'analyse des valeurs limites à 2 valeurs (2-value BVA), pour chaque valeur limite, il existe deux éléments de couverture (la valeur limite et son voisin le plus proche appartenant à la partition adjacente).  Comme les voisins les plus proches sont également des valeurs limites dans la partition adjacente, il n'y a alors que quatre éléments de couverture. \n\nDonc : \na) Incorrect. Seules 100 et 200 sont des éléments de couverture valides pour l'analyse des valeurs limites à 2 valeurs, on obtient donc une couverture de 50 %. \nb) Incorrect. Seules 100 et 200 sont des éléments de couverture valides pour l'analyse des valeurs limites à 2 valeurs, on obtient donc une couverture de 50 %. \nc) Incorrect. Seules 100 et 101 sont des éléments de couverture valides pour l'analyse des valeurs limites à 2 valeurs, on obtient donc une couverture de 50 %. \n<b>d) Correct. 101, 199 et 200 sont des éléments de couverture valides pour l'analyse des valeurs limites à 2 valeurs, on obtient donc une couverture de 75 %.</b>"
      },
      qc22: {
        en: "a) Is not correct. The combination (T, T, F) does not match any rule. This is an example of omission, not a contradiction \nb) Is not correct. The combination (T, F, T) matches only one column, R2, so there is no contradiction \nc) Is not correct. Both combinations (T, T, T) and (F, T, T) match only one column, R1, so there is no contradiction \n<b>d) Is correct. The combination (F, F, F) matches both R2 and R3, but R2 and R3 have different actions, so this shows a contradiction between R2 and R3.</b>",
        fr: "a) Incorrect. La combinaison (T, T, F) ne correspond à aucune règle. C'est un exemple d'omission, pas de contradiction. \nb) Incorrect. La combinaison (T, F, T) ne correspond qu'à une seule colonne, R2, il n'y a donc pas de contradiction. \nc) Incorrect. Les deux combinaisons (T, T, T) et (F, T, T) ne correspondent qu'à une seule colonne, R1, il n'y a donc pas de contradiction. \n<b>d) Correct. La combinaison (F, F, F) correspond à la fois à R2 et à R3, mais R2 et R3 ont des actions différentes, ce qui montre une contradiction entre R2 et R3.</b>"
      },
      qc23: {
        en: "The following three transitions: \n“REQUESTING -> CONFIRMED” \n“WAITING LIST -> CONFIRMED” \n“WAITING LIST -> END” \ncannot appear in the same test case, which suggests that at least three test cases are required. All the other transitions can appear in combination with one or more of these three transitions, so we need a minimum of three test cases. In fact, only three sequences are possible: \nTC1: START (Room request)  REQUESTING (Available)  \nCONFIRMED (Pay)  END \nTC2: START (Room request)  REQUESTING (Not available)  \nWAITING LIST (Available)  CONFIRMED (Pay)  END \nTC3: START (Room request)  REQUESTING (Not available)  \nWAITING LIST (Cancel)  END \n\nThus: \n<b>a) Is correct</b> \nb) Is not correct \nc) Is not correct \nd) Is not correct",
        fr: "Les trois transitions suivantes : \n“REQUESTING -> CONFIRMED” \n“WAITING LIST -> CONFIRMED” \n“WAITING LIST -> END” \nne peuvent pas apparaître dans le même cas de test, ce qui suggère qu'au moins trois cas de test sont nécessaires. Toutes les autres transitions peuvent apparaître en combinaison avec une ou plusieurs de ces trois transitions, nous avons donc besoin d'un minimum de trois cas de test. En fait, seules trois séquences sont possibles : \nSC1 : START (Demande de chambre) -> REQUESTING (Disponible) -> CONFIRMED (Paiement) -> END \nSC2 : START (Demande de chambre) -> REQUESTING (Non disponible) -> WAITING LIST (Disponible) -> CONFIRMED (Paiement) -> END \nSC3 : START (Demande de chambre) -> REQUESTING (Non disponible) -> WAITING LIST (Annuler) -> END \n\nDonc : \na) Correct. Les trois scénarios de test (SC1, SC2 et SC3) couvrent toutes les transitions valides du diagramme d'état de transition. \nb) Incorrect. Deux cas de test ne seraient pas suffisants pour couvrir toutes les transitions valides. \nc) Incorrect. Cinq cas de test ne sont pas nécessaires car trois scénarios de test suffisent pour couvrir toutes les transitions valides. \nd) Incorrect. Six cas de test ne sont pas nécessaires car trois scénarios de test suffisent pour couvrir toutes les transitions valides. "
      },
      qc24: {
        en: "In branch testing the coverage items are branches, which are represented by the edges of a control flow graph. There are 8 edges in the control flow graph. \n\nThus: \na) Is not correct \nb) Is not correct \n<b>c) Is correct</b> \nd) Is not correct ",
        fr: "En test par branche, les éléments de couverture sont les branchements, représentés par les arêtes d'un graphe de flux de contrôle. Le graphe de flux de contrôle en question comporte 8 arêtes.\n\nDonc :\na) Incorrect. 2 ne correspond pas au nombre d'arêtes du graphe de flux de contrôle.\nb) Incorrect. 4 ne correspond pas au nombre d'arêtes du graphe de flux de contrôle.\n<b>c) Correct. 8 correspond au nombre d'arêtes du graphe de flux de contrôle, qui représentent les éléments de couverture pour le test par branche.</b>\nd) Incorrect. 7 ne correspond pas au nombre d'arêtes du graphe de flux de contrôle."
      },
      qc25: {
        en: "<b>a) Is correct. Performing only black-box testing does not provide a measure of actual code coverage. White-box coverage measures provide an objective measurement of coverage and provide the necessary information to allow additional tests to be generated to increase this coverage, and subsequently increase confidence in the code</b> \nb) Is not correct. This statement is correct, but it has nothing to do with black-box testing \nc) Is not correct. In general there are no subsumes relationships between white-box and black-box techniques \nd) Is not correct. White-box techniques are used to design tests based on the test object itself, while black-box techniques are used to design tests based on the specification. Therefore, there is no relation between coverage items derived from these two types of techniques",
        fr: "<b>a) Correct. Effectuer uniquement des tests en boîte noire ne permet pas de mesurer la couverture réelle du code. Les mesures de couverture en boîte blanche fournissent une mesure objective de la couverture et donnent les informations nécessaires pour générer des tests supplémentaires afin d'augmenter cette couverture, et par conséquent, la confiance dans le code.</b> \nb) Incorrect. Cet énoncé est correct, mais il n'a aucun rapport avec les tests en boîte noire. \nc) Incorrect. En général, il n'y a pas de relation de subsomption entre les techniques en boîte blanche et en boîte noire. \nd) Incorrect. Les techniques en boîte blanche sont utilisées pour concevoir des tests basés sur l'objet de test lui-même, tandis que les techniques en boîte noire sont utilisées pour concevoir des tests basés sur la spécification. Par conséquent, il n'y a pas de relation entre les éléments de couverture dérivés de ces deux types de techniques."
      },
      qc26: {
        en: "a) Is not correct. Exploratory testing uses test charters, not a list of possible defects/failures. Although exploratory testing can incorporate the use of other test techniques, in this case fault attack is the most likely option \n<b>b) Is correct. This is a list of possible failures. Fault attacks are a methodical approach to the implementation of error guessing and require the tester to create or acquire a list of possible errors, defects and failures, and to design tests that will identify defects associated with the errors, expose the defects, or cause the failures</b> \nc) Is not correct. The tester is using a checklist of items to support their testing. Both error guessing and checklist-based testing use such lists, however, the list here is of possible failures, not test conditions, and so the MOST PROBABLE test technique is fault attack, which focuses on errors, defects and failures \nd) Is not correct. BVA is based on an analysis of boundary values of equivalence partitions. The above list does not mention equivalence partitions or their boundaries",
        fr: "a) Incorrect. Le test exploratoire utilise des chartes de test, et non une liste de défauts/erreurs possibles. Bien que le test exploratoire puisse intégrer l'utilisation d'autres techniques de test, dans ce cas, l'attaque par injection de faille est l'option la plus probable. \n<b>b) Correct. Il s'agit d'une liste d'échecs possibles. Les attaques par injection de faille sont une approche méthodique de la mise en œuvre de la supposition d'erreurs. Elles nécessitent du testeur qu'il crée ou acquiert une liste d'erreurs, de défauts et d'échecs possibles, et qu'il conçoive des tests qui permettront d'identifier les défauts associés aux erreurs, d'exposer les défauts ou de provoquer les échecs.</b> \nc) Incorrect. Le testeur utilise une liste de contrôle d'éléments pour appuyer ses tests. Le test par supposition d'erreurs et le test basé sur une liste de vérification utilisent tous deux de telles listes. Cependant, la liste ici est composée d'échecs possibles, et non de conditions de test. Ainsi, la technique de test la PLUS PROBABLE est l'attaque par injection de faille, qui se concentre sur les erreurs, les défauts et les échecs. \nd) Incorrect. L'analyse des valeurs limites (BVA) est basée sur une analyse des valeurs limites des partitions d'équivalence. La liste ci-dessus ne mentionne pas les partitions d'équivalence ou leurs limites."
      },
      qc27: {
        en: "a) Is not correct. Although it is true that the tester can implement and execute detailed test cases based on the checklist, it does not explain how this would result in increased coverage \nb) Is not correct. Checklist items should not be automated. But even if they are, the automated test scripts always execute the tests in the same way, which usually does not result in increased coverage \nc) Is not correct. It is true that each checklist item should be tested separately and independently. But this impacts the test execution order and does not impact the achieved coverage, and so does not result in increased coverage \n<b>d) Is correct. If the checklists are high-level, some variability in the actual testing is likely to occur, resulting in potentially greater coverage but less repeatability. If two testers follow a checklist of high-level items, each of them may use different test data, test steps, etc. This way, one tester will probably cover some areas not covered by the other tester and this will result in increased coverage</b>",
        fr: "a) Incorrect. Bien qu'il soit vrai que le testeur puisse mettre en œuvre et exécuter des cas de test détaillés basés sur la liste de vérification, cela n'explique pas comment cela se traduirait par une couverture accrue. \nb) Incorrect. Les éléments de la liste de vérification ne doivent pas être automatisés. Même s'ils le sont, les scripts de test automatisés exécutent toujours les tests de la même manière, ce qui n'entraîne généralement pas une couverture accrue. \nc) Incorrect. Il est vrai que chaque élément de la liste de vérification doit être testé séparément et indépendamment. Mais cela a un impact sur l'ordre d'exécution des tests et n'a pas d'impact sur la couverture atteinte, et donc n'entraîne pas une couverture accrue. \n<b>d) Correct. Si les listes de vérification sont de haut niveau, une certaine variabilité dans les tests réels est susceptible de se produire, ce qui se traduit potentiellement par une couverture plus importante mais une moins bonne répétabilité. Si deux testeurs suivent une liste de vérification d'éléments de haut niveau, chacun d'eux peut utiliser des données de test, des étapes de test, etc. différentes. De cette façon, un testeur couvrira probablement certaines zones non couvertes par l'autre testeur, ce qui se traduira par une couverture accrue.</b>"
      },
      qc28: {
        en: "a) Is not correct. This acceptance criterion describes what rules or regulations the system must adhere to (in this case, the right to be forgotten). This is an example of a rule-oriented acceptance criterion \n<b>b) Is correct. This acceptance criterion describes an example scenario that must be realizable by the system. This is an example of a scenariooriented acceptance criterion</b> \nc) Is not correct. This sentence looks more like a line of code that implements some business rule. Acceptance criteria should be written in collaboration with business representatives, and therefore should be written in language they understand. This sentence will most likely be unintelligible to these stakeholders \nd) Is not correct. This acceptance criterion describes what rules or regulations the system must adhere to and how compliance will be ensured. Therefore, this is an example of a rule-oriented acceptance criterion, not a scenario-based acceptance criterion",
        fr: "a) Incorrect. Ce critère d'acceptation décrit les règles ou réglementations auxquelles le système doit adhérer (dans ce cas, le droit à l'oubli). Il s'agit d'un exemple de critère d'acceptation orienté règle. \n<b>b) Correct. Ce critère d'acceptation décrit un exemple de scénario qui doit être réalisable par le système. Il s'agit d'un exemple de critère d'acceptation orienté scénario.</b> \nc) Incorrect. Cette phrase ressemble plus à une ligne de code qui implémente une règle métier. Les critères d'acceptation doivent être rédigés en collaboration avec les représentants de l'entreprise et doivent donc être rédigés dans un langage qu'ils comprennent. Cette phrase sera probablement incompréhensible pour ces parties prenantes. \nd) Incorrect. Ce critère d'acceptation décrit les règles ou réglementations auxquelles le système doit adhérer et la manière dont la conformité sera assurée. Il s'agit donc d'un exemple de critère d'acceptation orienté règle, et non d'un critère d'acceptation orienté scénario."
      },
      qc29: {
        en: "",
        fr: ""
      },
      qc30: {
        en: "",
        fr: ""
      }
    }
  
    return explanations[questionId]?.[language] || ''
  }